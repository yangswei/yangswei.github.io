<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杨世威</title>
    <description>欢迎来到我的个人站~</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 27 Dec 2019 11:35:53 +0800</pubDate>
    <lastBuildDate>Fri, 27 Dec 2019 11:35:53 +0800</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>zabbix生产实践</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;背景:目前项目上k8s集群的监控采用标准的prometheus+altermanager+hook(hook是我这边收集处理告警的程序后续如果想写的话专门写一篇来介绍)但宿主机的各项指标监控prometheus覆盖不完全,针对windows、mac等各类平台的监控目前还是开源的zabbix比较完善&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;服务端部署&quot;&gt;服务端部署&lt;/h3&gt;

&lt;p&gt;本篇文章是基于github作者jangaraj的项目进行部署的,上一个版本的xxl持续使用了很久,效果不错,本次是基于新的项目docbix-xxl进行部署的&lt;br /&gt;
&lt;a href=&quot;https://github.com/monitoringartist/dockbix-xxl/blob/master/Dockerfile/dockbix-xxl-4.0/docker-compose.yml&quot;&gt;项目地址&lt;/a&gt;&lt;br /&gt;
server端的部署很简单,docker-compose文件如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-compose&quot;&gt;version: '3.1'
services:
  zabbixdb:
    image: monitoringartist/zabbix-db-mariadb:latest
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - /xxx/mysqldata:/var/lib/mysql
      - /xxx/mysqlconf/myconf.cnf:/etc/my.cnf.d/myconf.cnf
    environment:
      - MARIADB_USER=zabbix
      - MARIADB_PASS=xxxxxx
  zabbixserver:
    image: monitoringartist/dockbix-xxl:latest
    depends_on:
      - zabbixdb
    ports:
      - &quot;1180:80&quot;
      - &quot;10051:10051&quot;
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - /xx/internalter:/usr/local/share/zabbix/alertscripts
      - /xx/externalter:/usr/local/share/zabbix/externalscripts
      - /xx/zabbix_server.conf:/usr/local/etc/zabbix_server.conf
    environment:
      - ZS_DBHost=zabbixdb
      - ZS_DBUser=zabbix
      - ZS_DBPassword=xxxxxxxxx
      - XXL_zapix=true
      - XXL_grapher=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于官方的文档做了一些调整&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;修改docbix,增加了python的requests库主要用于python脚本发送告警&lt;br /&gt;
[测试过程中貌似docbix的python已经装好了requests,这里为了后续方便添加,还是额外增加一下]&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据持久化&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;/xxx/mysqldata:/var/lib/mysql&lt;/code&gt;将mysql的数据落地到宿主机&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加自定义脚本&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;/xx/internalter:/usr/local/share/zabbix/alertscripts&lt;/code&gt;宿主机的告警脚本就能在前端-管理-告警媒介类型中直接添加后,让zabbix调用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加配置文件解决报错&lt;br /&gt;
报错: &lt;code class=&quot;highlighter-rouge&quot;&gt;Aborted connection 111 to db: 'zabbix' user: 'zabbix' host: 'xx.5.5.5' (Got an error reading communication packets)&lt;/code&gt;&lt;br /&gt;
解决办法是先挂载mysql的配置文件和zabbix的配置文件,然后启动&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose up -d&lt;/code&gt; &lt;br /&gt;
启动后,zabbix的配置被初始化覆盖掉了,重新将配置写入/xx/zabbix_server.conf文件中,然后&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose restart zabbixdb&lt;/code&gt;即可&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/xx/zabbix_server.conf:/usr/local/etc/zabbix_server.conf&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/xxx/mysqlconf/myconf.cnf:/etc/my.cnf.d/myconf.cnf&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中dockerfile如下:&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; monitoringartist/dockbix-xxl:latest&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; python-pip &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;    pip &lt;span class=&quot;nb&quot;&gt;install  &lt;/span&gt;requests
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;mysql的conf如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysqlconf&quot;&gt;open_files_limit = 4800
max_connections = 500
innodb_log_buffer_size = 32M
innodb_log_file_size = 2047M
innodb_buffer_pool_instances = 18
innodb_buffer_pool_size=18G
max_allowed_packet = 1024M
join_buffer_size = 1M
log_warnings = 2
log_error_verbosity = 3
slow_query_log
query_cache_size = 0
query_cache_type = 0
skip-name-resolve=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;zabbix_server.conf:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-zabbixconf&quot;&gt;User=zabbix
SSLKeyLocation=xxx/ssl/keys
SSLCertLocation=/xxx/ssl/certs
SNMPTrapperFile=/xxps.tmp
PidFile=/xx.pid
LogType=console
LoadModulePath=/usr/lib/zabbix/modules
JavaGatewayPort=10052
JavaGateway=127.0.0.1
ExternalScripts=/xxs
DBUser=zabbix
DBPort=3306
DBPassword=xxx
DBName=zabbix
DBHost=zabbixdb
AlertScriptsPath=/usr/local/share/zabbix/alertscripts
---  以上部分是每次启动zabbix时自动覆盖的 ---
LogFileSize=4
DebugLevel=5
StartPollers=102
StartPreprocessors=72
StartPollersUnreachable=14
StartTrappers=64
StartEscalators=2
StartAlerters=4
MaxHousekeeperDelete=8400
CacheSize=72M
StartDBSyncers=24
HistoryCacheSize=64M
HistoryIndexCacheSize=32M
TrendCacheSize=42M
ValueCacheSize=64M
Timeout=30
TrapperTimeout=300
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;客户端&quot;&gt;客户端&lt;/h3&gt;
&lt;p&gt;客户端如果使用默认只需要1.2.5步骤即可
客户端用ansible批量分发到机器的&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;通过rpm包安装client.zabbix-agent-3.2.0-1.el7.x86_64.rpm&lt;/li&gt;
  &lt;li&gt;将配置文件覆盖/etc/zabbix/zabbix_agentd.conf&lt;/li&gt;
  &lt;li&gt;加载自定义监控键值&lt;/li&gt;
  &lt;li&gt;创建目录,放入自定义键值依赖的脚本以及zabbix-client的启动脚本等(需要有执行权限)&lt;/li&gt;
  &lt;li&gt;启动zabbix-client&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;agent-conf,如果是像我批量推送,配置文件中ListenIP获取各机器的对应ip即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PidFile=xxx/xx/zabbix.pid
LogFile=xxx/xxx/agent.log
LogFileSize=0
Server=xxx
ServerActive=xxx
HostnameItem=system.hostname
Include=/etc/zabbix/zabbix_agentd.d/*.conf
ListenIP=xxx
StartAgents=5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;自定义监控键值userparameter.conf,放入到Include的路径中,这里放入/etc/zabbix/zabbix_agentd.d/下&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;UserParameter=tcp[*],/scripts/tcp_status_ss.sh $1&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自定义脚本,4步骤生成/scripts目录后放入脚本&lt;br /&gt;
本脚本基于ss,监控各服务器连接状态监测脚本&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;SYNRECV &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
/usr/sbin/ss &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'synrecv'&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{print $2}'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;ESTAB &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
/usr/sbin/ss &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'estab'&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{print $2}'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;FINWAIT1 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
/usr/sbin/ss &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; |  &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'FIN-WAIT-1'&lt;/span&gt;|wc &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;FINWAIT2 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
/usr/sbin/ss &lt;span class=&quot;nt&quot;&gt;-ant&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'FIN-WAIT-2'&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;TIMEWAIT &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
/usr/sbin/ss &lt;span class=&quot;nt&quot;&gt;-ant&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'TIME-WAIT'&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;LASTACK &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
/usr/sbin/ss &lt;span class=&quot;nt&quot;&gt;-ant&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'LAST-ACK'&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;LISTEN &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
/usr/sbin/ss &lt;span class=&quot;nt&quot;&gt;-ant&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'LISTEN'&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;zabbix启停脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; /etc/rc.d/init.d/functions
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-x&lt;/span&gt; /usr/sbin/zabbix_agentd &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;zabbix_agentd
&lt;span class=&quot;k&quot;&gt;else
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;5
&lt;span class=&quot;k&quot;&gt;fi

&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;##*/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;conf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/xxx/zabbix_agentd.conf                                          &lt;span class=&quot;c&quot;&gt;#这里填写对应的zabbix配置文件全路径&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;pidfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;^PidFile=.*$&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$conf&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;cut&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f2&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;tr&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'\r'&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#这里从配置文件中取pid文件&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; /etc/sysconfig/zabbix-agent &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; /etc/sysconfig/zabbix-agent
&lt;span class=&quot;k&quot;&gt;fi

&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lockfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lock/subsys/zabbix-agent

start&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;$&quot;Starting Zabbix agent: &quot;&lt;/span&gt;
    daemon &lt;span class=&quot;nv&quot;&gt;$exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$conf&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;rv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$rv&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$lockfile&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$rv&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

stop&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;$&quot;Shutting down Zabbix agent: &quot;&lt;/span&gt;
    killproc &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$pidfile&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$timeout&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$prog&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;rv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$rv&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$lockfile&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$rv&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

restart&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    stop
    start
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in
    &lt;/span&gt;start|stop|restart&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
    force-reload&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        restart
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
    status&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        status &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$pidfile&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$prog&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
    try-restart|condrestart&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;status &lt;span class=&quot;nv&quot;&gt;$prog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/dev/null &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
            &lt;/span&gt;restart
        &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
    reload&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        action &lt;span class=&quot;s2&quot;&gt;$&quot;Service &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;##*/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; does not support the reload action: &quot;&lt;/span&gt; /bin/false
        &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;3
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;$&quot;Usage: &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; {start|stop|status|restart|try-restart|force-reload}&quot;&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;2
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;esac&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;前端&quot;&gt;前端&lt;/h3&gt;
&lt;p&gt;zabbix启动后暴露的端口是10050 &lt;br /&gt;
在nginx层将域名请求转发到10050,即可通过域名登录,默认账号Admin密码zabbix&lt;br /&gt;
前端主要做几件事情:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;自动发现-ip范围-检查（端口范围10050,键值system.uname）&lt;/li&gt;
  &lt;li&gt;配置-动作,右上角事件源选择自动注册-创建动作,将主机自动注册到对应的监控模板上&lt;/li&gt;
  &lt;li&gt;管理-报警媒介类型,这里添加告警脚本即对应服务端部署中&lt;code class=&quot;highlighter-rouge&quot;&gt;/xx/internalter:/usr/local/share/zabbix/alertscripts&lt;/code&gt;下的脚本名&lt;/li&gt;
  &lt;li&gt;自定义监控键值(可选择主机添加或模板添加),这里键值对应的是client端的userparameter.conf,创建监控项-键值tcp[xxx]这里xxx是传参到&lt;code class=&quot;highlighter-rouge&quot;&gt;/scripts/tcp_status_ss.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;文章没有添加截图,欢迎大家交流,另外github那个问题周末找时间给作者提个issue看是否可以直接处理掉~&lt;/p&gt;
</description>
        <pubDate>Wed, 25 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/12/zabbix/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/zabbix/</guid>
        
        <category>zabbix</category>
        
        
      </item>
    
      <item>
        <title>19年圣诞,一些感想</title>
        <description>&lt;h3 id=&quot;最近负能量较多谨慎观看&quot;&gt;最近（负能量较多，谨慎观看…）&lt;/h3&gt;

&lt;p&gt;突然想写点什么，很多想写的，不知道怎么全部表达出来，等慢慢输出到屏幕，又忘记要说的核心内容有哪些，就随笔写写吧&lt;br /&gt;
时隔上次写博客，一个月10天，上次博客还是在碧波路888号畅兴大厦完成的，随着teambition融入阿里巴巴，投入到一顿天昏地暗的忙碌中，直到今天才算缓一口气
这段时间的一顿消耗，整个人都非常嗜睡外加一些精神敏感，尤其是连续的加班到凌晨，顶着红眼睛睡觉，闭上眼感觉眼球干涩到没办法转动，迫于无奈，滴点眼药水赶紧转动一下眼球快速入眠&lt;br /&gt;
早上又不得不准点到公司，线上的事情离不开也没办法请假，那段时间每天打车上车就带上耳机赶紧闭上眼睛，让眼球能多休息一会儿&lt;br /&gt;
因为开始写一些Python的东西，想着抽点时间写一写，一到公司身边各个开发应接不暇，那几个礼拜，我都是只能用下班后到晚上回家前挤出时间来写代码，或者就是周末到星巴克，效率出奇的高&lt;br /&gt;
慢慢脾气也不好了，因为日常再忙碌，解决的问题再多，这都不会算到kpi,上半年给到的A就是很好的证明 &lt;br /&gt;
说起来整个人的思路也在变化 &lt;br /&gt;
刚到公司的几个月想的事情是赶紧上手，能做什么事就着手做什么事情&lt;br /&gt;
半年后，开始规划一些更效率更快捷的方式，也开始从开始的实施开始更多的接手线上业务&lt;br /&gt;
线上的事情从陌生到熟悉是个很让人兴奋的过程，虽然到写博客这天，对线上环境的了解大约在80%左右， 但是80%涵盖了几乎日常要处理的90%的事务 &lt;br /&gt;
开始很憋屈的阶段应该是从上次A过后，给的理由是听到了抱怨，而不是解决问题的决心 &lt;br /&gt;
其实一直尝试去解决一些事情，也经手解决了很多事情，投入更加多精力到了线上的 &lt;br /&gt;
经历那次绩效后，我也开始反思了，怎么样算是有贡献呢？&lt;br /&gt;
对于领导者而言，并非你每天投入大量精力去做你力所能及的事情，就会给你很高的评价 &lt;br /&gt;
但是对于职位而言，很多事情又是一定要做的  &lt;br /&gt;
对于我而言，我很长时间里面手机夜间都是开声音的，每天对接很多很多的事情，曾经一度觉得很充实..  &lt;br /&gt;
经过反思，我想通了一些东西，就是要做一些你的短板，就是每年年终总结上你觉得哪里不足的事情 - - 
原先公司私有部署，共有云当时的我几乎全盘接下到后面除了线上各类业务就是无穷尽的私有部署&lt;br /&gt;
现在手头上还有十几个私有部署客户，但现阶段准备把重心拉回到写代码上面，做一些非能力点之外的事才算是突破&lt;br /&gt;
公有云的事情远比领导想象的多，之前很多我感觉做了领导就能知道或者感受得到，但是并非如此 &lt;br /&gt;
在各种熬夜加班的干到21号迁移的那天凌晨后，因为新的环境要对接告警，老的环境告警不断，而我手头上并行了3-4件事一直在处理&lt;br /&gt;
领导质问了各种，这个任务分给你一个礼拜了，怎么还没搞?&lt;br /&gt;
来了告警，这个告警你跟进了吗？&lt;br /&gt;
迁移的事情，这个事情你得一直催某某团队的人去做知道吗？&lt;br /&gt;
真的想喷回去，一个礼拜做了多少事你心里有点数吗，对接全量线上业务处理是玩呢吗？告警？我只是做了个告警接入跟输出，线上所有告警全部我来处理了么，肯定都是要输出的，告警跟进肯定要一起跟进，告警还不如发给我个人，给搞个告警群干嘛？&lt;br /&gt;
结果却是：怎么没搞？emm事情太多了，没来得及~巴拉巴拉，催任务老老实实去@人家老大，虽然没一个老大鸟我，最后我去给人家直接改代码，呵呵，总算是把事情完成了  &lt;br /&gt;
告警那件事被说后真的忍不住了..感觉没有意义一味的闷不做声..&lt;br /&gt;
当时大概凌晨5:00多，怼了回去，领导让我回去自己想想..&lt;br /&gt;
现在的我很慌，并且决定明年跳槽了~~
接下来的日子，多写一写代码，一切顺其自然，尽量改变自己，变得随性一些  &lt;br /&gt;
吐槽了一堆负能量，那接下来说一些其他的想法吧&lt;/p&gt;

&lt;h3 id=&quot;其他的一些感想&quot;&gt;其他的一些感想&lt;/h3&gt;

&lt;p&gt;人时时刻刻都会受到身边人的影响或多或少，而世界观这个东西会变但是会很慢&lt;br /&gt;
前天和妈妈通过电话，聊到她准备今年退休了，我笑着问她，退休了准备去哪里玩，要不要来上海，妈妈拒绝我了~ &lt;br /&gt;
挂掉电话后，感触颇多，联想到之前给妈妈写家书，时间过得真的特别的快，而且人有一种特别神奇的思维，每每经历一些仪式才会意识到时间的流逝。而往往能记忆的也是一些仪式
对于以往的日子，我经常觉得我是一个幸运的人。&lt;br /&gt;
而这份幸运总的来说，就是不去故意伤害别人，心存善良，努力真的会有回报…&lt;/p&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;p&gt;公司搬迁后，买了两只守宫，上周加班逃逸了一只，还剩一只~&lt;br /&gt;
家里的鱼很久没管了，冬季就两周喂喂食物&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/12/somdiff/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/somdiff/</guid>
        
        <category>diary</category>
        
        
      </item>
    
      <item>
        <title>如何将服务运行在k8s中</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;距离上次更新正好一个月，因为公司马上要搬家了，最近各种环境的迁移，进公司以后除了负责线上的运维还需要分出精力去搞公司的私有客户,最近终于从私有客户那边抽出来，全心投入到公有云的线上运维来了！开始找俊奇大佬要一些简单的需求，写一写接口，多写写抓紧入门一下，这篇文章算是应用容器化+k8s上线的入门教程了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;如何将服务运行在k8s中&quot;&gt;如何将服务运行在k8s中&lt;/h1&gt;

&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;

&lt;p&gt;这篇文章建立在，已经准备好了如下的环境的基础上，如果没有可以找找教程，自行测试k8s太重的话可以弄轻量的k3s都可以&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;python3，docker&lt;/li&gt;
  &lt;li&gt;k8s，私有仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;开发过程&quot;&gt;开发过程&lt;/h3&gt;

&lt;p&gt;因为刚写python，所以这里以python的代码为例，其他语言的均类似&lt;br /&gt;
下面是简单的Hello world进程，程序默认的监听端口是8080&lt;br /&gt;
（当然在我们生产上会有很多复杂的场景，这里只介绍基本情况，就是服务只监听一个端口的情形）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-app.py&quot;&gt;from flask import Flask
app = Flask(__name__)

@app.route(&quot;/&quot;)
def hello():
    return &quot;Hello world!&quot;

if __name__ == &quot;__main__&quot;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;容器化&quot;&gt;容器化&lt;/h3&gt;

&lt;p&gt;接下来就是怎么将各种语言写的代码容器化的操作了&lt;br /&gt;
以python为例,dockerfile很简单&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; python:3.6.4&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; /code &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;apt-get update &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;freetds-dev &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;unixodbc-dev
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; . /code &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; requirements.txt /code&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;pip &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; /code/requirements.txt &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; https://pypi.douban.com/simple
&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; /code&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; [&quot;python3&quot;,&quot;/code/xx.py&quot;,&quot;8060&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FROM一个基础环境，如果你是node开发from一个node的镜像作为基础环境&lt;br /&gt;
RUN 是构建镜像过程中执行指令，这里是运行安装一些基础依赖，这个根据应用来&lt;br /&gt;
基础依赖安装完成后，将代码，以及python依赖的库安装一下&lt;br /&gt;
CMD 则是运行这个容器的最后一条命令&lt;/p&gt;

&lt;p&gt;实际生产环境会要求镜像包最小化&lt;br /&gt;
有一些基础的技巧，可以使最终生成的包大小减少很多。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;dockerfile每条命令相当于在基础镜像上包了一层，所以用连接符减少指令行数&lt;/li&gt;
  &lt;li&gt;multistage builds 这个很好用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面以实际生产中multistage为例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mutidockerfile&quot;&gt;  FROM xxx/node:6.11.2 AS builder
  WORKDIR /app
  COPY package.json ./package.json
  COPY yarn.lock ./
  RUN yarn install  &amp;amp;&amp;amp; yarn cache clean
  FROM node:6.11.2
  WORKDIR /xxx
  COPY --from=builder /xxx/node_modules /xxx/node_modules
  COPY . .
  EXPOSE 5000
  CMD npm start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生产中尽量把构建过程拆分开，最终镜像只需要从过程镜像获取构建好的依赖&lt;/p&gt;

&lt;h3 id=&quot;私有仓库&quot;&gt;私有仓库&lt;/h3&gt;

&lt;p&gt;这里不过多介绍，镜像推送私有仓库很简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmd&quot;&gt;docker build -t xxx:v0.0.1 .  
docker push xxxx:v0.0.1  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;kubernetes创建应用&quot;&gt;kubernetes创建应用&lt;/h3&gt;

&lt;p&gt;下面我先附上deploy文件,再介绍下里面的内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-deployment&quot;&gt;apiVersion: v1
kind: Service
metadata:
  name: xxx(应用名)
  namespace: release(namespace名)
  labels:
    app: xxx(应用名)
    service: xxx(应用名)
spec:
  ports:
  - port: 8060
    name: http
  selector:
    app: xxx(应用名)
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: xxx(应用名)
  namespace: release(namespace名)
  labels:
    app: xxx(应用名)
    version: v1
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: xxx(应用名)
        version: v1
    spec:
      containers:
      - name: xxx(应用名)
        image: xxx:v0.0.1(这里是我们刚推送到私有仓库的地址)
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8060
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我创建了两个资源，kind分别是service和deployment&lt;br /&gt;
service用于将port映射出去&lt;br /&gt;
deployment描述pod信息&lt;br /&gt;
因为我这里服务只需要内部调用，所以这里没有将端口暴露出去&lt;br /&gt;
实际生产环境中，除了需要暴露端口，类似证书，配置文件均可以通过configmap的形式挂载到pod中去&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-deploymentrelease&quot;&gt;apiVersion: v1
kind: Service
metadata:
  name: appnamexx
  namespace: namespacexx
  labels:
    app: appnamexx
spec:
  selector:
    app: appnamexx
  type: NodePort
  ports:
  - name: appnamexx
    port: portxx
    nodePort: nodeportxx
    protocol: TCP
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name:  appnamexx
  namespace: namespacexx
spec:
  minReadySeconds: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  replicas: replicas
  template:
    metadata:
      labels:
        app:  appnamexx
    spec:
      securityContext:
        runAsUser: someuserxx
        fsGroup: somegroupxx
      containers:
      - name: appnamexx
        image: imageaddrxx
        resources:
          limits:
            cpu: 100m
            memory: 1000Mi
          requests:
            cpu: 100m
            memory: 500Mi
        livenessProbe:
          httpGet:
            path: /checkalive
            port: portxx
            scheme: HTTP
          initialDelaySeconds: 60
          timeoutSeconds: 5
        readinessProbe:
          httpGet:
            path: /probe
            port: portxx
            scheme: HTTP
          initialDelaySeconds: 3
          timeoutSeconds: 5
        ports:
        - containerPort: portxx
          name: http
          protocol: TCP
        env:
          - name: SOME_ENVXX
            value: xxx
        volumeMounts:
          - name: configvolumexx
            mountPath: configpathxx
      volumes:
      - name: configvolumexx
        configMap:
          name: app's config

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到生产环境多了很多配置，除了nodeport将应用的端口映射出去&lt;br /&gt;
还增加了类似pod内存，cpu资源分配的限制&lt;br /&gt;
配置文件的挂载，注意volumes和volumeMounts对应的name要一致，并且这个名字和k8s的configmap的资源名都保持一致才能将congfigmap挂载到对应的pod中去&lt;/p&gt;

&lt;h3 id=&quot;上线调试&quot;&gt;上线&amp;amp;调试&lt;/h3&gt;

&lt;p&gt;上线就是apply对应的资源，最终调试可以参考上一篇讲nginx时讲到的本地调试方式进行本地调试，本地开发环境并不需要打包到镜像并发送到k8s的pod才能调试。只需在nginxcallback到本地的端口即可&lt;/p&gt;

&lt;h3 id=&quot;欢迎大佬交流探讨&quot;&gt;欢迎大佬交流探讨&lt;/h3&gt;

&lt;p&gt;页面中有邮箱和github联系方式，欢迎大佬们和我沟通交流，一起学习进步&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/appink8s/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/appink8s/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Nginx生产实践</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;生产环境nginx，主要接收最前端的流量，然后负载均衡或者引流。记录下目前Nginx常用的一些配置与作用说明，通过这篇文章，可以了解到生产上各种nginx的使用方法与基础技巧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;常用的一些nginx配置&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;测试环境本地项目调试&lt;/li&gt;
  &lt;li&gt;测试环境多端口调试&lt;/li&gt;
  &lt;li&gt;rewrite常用用法&lt;/li&gt;
  &lt;li&gt;root&amp;amp;alias用法与区别&lt;/li&gt;
  &lt;li&gt;生产环境切换&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;测试环境本地项目调试&quot;&gt;测试环境本地项目调试&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-nginx-1&quot;&gt;server {
    listen 80;
    server_name xxx;
    error_page 502 503 504 = @backurl;
    location / {
        proxy_pass http://$remote_addr:8888;
        proxy_set_header Host $http_host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-NginX-Proxy true;
        proxy_set_header X-Real-IP $remote_addr;
    }
    location @backurl {
        proxy_pass http://127.0.0.1:8888;
        proxy_set_header Host $http_host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-NginX-Proxy true;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求工作方法： 访问对应server时，首先找location对应的url,url则指向remote_addr(客户端IP,注意这里的remote_addr需要在nginx设置获取真实ip配置)，当客户端本地未监听8888时，则重新将location指向服务端的8888,即完成测试环境代理本地项目测试需求&lt;/p&gt;

&lt;h3 id=&quot;测试环境多端口调试&quot;&gt;测试环境多端口调试&lt;/h3&gt;
&lt;p&gt;同一服务在测试环境部署N个，那么如何在浏览器指定port请求对应服务？&lt;br /&gt;
通过cookie是一种方法,与测试项目本地调试的配置类似&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-port-nginx&quot;&gt;    location / {
        if ($cookie_port) {
          set $apiport $cookie_port;
        }
        proxy_pass http://$remote_addr:$apiport;
        proxy_set_header Host $http_host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-NginX-Proxy true;
        proxy_set_header X-Real-IP $remote_addr;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实只需要nginx获取到客户端请求时传输的port变量即可，这里将port信息放到cookie中，同样可以放到请求的head中，nginx通过http_x_port来进行反代即可&lt;/p&gt;

&lt;h3 id=&quot;rewrite常用用法&quot;&gt;rewrite常用用法&lt;/h3&gt;

&lt;p&gt;rewrite为了改写请求url,改变浏览器中的请求地址&lt;br /&gt;
有四个标签：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;last      匹配后继续匹配其他规则&lt;/li&gt;
  &lt;li&gt;break     匹配后不匹配其他规则&lt;/li&gt;
  &lt;li&gt;redirect  临时重定向&lt;/li&gt;
  &lt;li&gt;permanent 永久重定向&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用法1：location中直接将url第一个根路径以前的url替换成rewrite指定的url,正则有很多，具体参考nginx-rewrite正则相关的文章&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-rewrite&quot;&gt;  rewrite ^/(.*) http://www.taobao.com/$1 permanent;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法2：例如请求的url是&lt;code class=&quot;highlighter-rouge&quot;&gt;taobao.com/xxx/aa&lt;/code&gt;则rewrite成&lt;code class=&quot;highlighter-rouge&quot;&gt;taobao.com/aa&lt;/code&gt;并执行pass的跳转并且不会继续匹配aa对应的location&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-rewrite2&quot;&gt;location /xxx {
    rewrite ^/xxx(.*) $1 break;
    proxy_pass http://xx.xx.xx.xx:port;
}
location /aa {
    dosomething
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法3：在if判断中,例如如下防盗链配置请求资源。除none blocked域名外其他均rewrite掉&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ifrewrite&quot;&gt;server {
  listen 8080;
  server_name xxx.abc.com
  location ~* ^.+\.(gif|jpg|png|swf|flv|rar|zip)$ {                                   ## location /xx/ {
                                                                                      ##    root /xxx/xx;
    valid_referers none blocked www.xxx.com www.yyy.com *.baidu.com  *.tabobao.com;
    if ($invalid_referer) {
      rewrite ^/ http://www.xxx.com/images/forbidden.png;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rewrite使用方面有很多场景官方文档有详细说明：&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;跳转&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;alias用法与区别&quot;&gt;alias用法与区别&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;root处理结果是将url指向location路径+root路径&lt;/li&gt;
  &lt;li&gt;alias的处理结果是：使用alias路径替换location路径&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;alias目录名后面一定要加”/”，alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用，alias只用于location中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-location-alias&quot;&gt;location ^~ /t/ {
 alias /www/root/xxx/;
}
location = /favicon.ico {
    alias /xxx/favicon.ico;
    break;
}
location /xxx {
    alias /xxx/dist;
    index index.html;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;生产环境切换&quot;&gt;生产环境切换&lt;/h3&gt;

&lt;p&gt;环境切换与端口切换类似，方法可以通过head或者cookie等进行传参，nginx中进行判断，根据不同的变量，进行不同的跳转&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根据来源ip进行跳转&lt;/li&gt;
  &lt;li&gt;根据cookie是否包含version字段进行跳转&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-change&quot;&gt;        location /xxx/ {
            set $xxxpassurl http://xxx-release;
                if ($remote_addr ~ '(xx.xx.xx.x1|xx.xx.xx.x2)' ) {
                        set $xxxpassurl http://xxx-test;
                }
                if ($http_cookie ~ version\=release) {
                        set $xxxpassurl http://xxx-release;
                }
                if ($http_cookie ~ version\=ga) {
                        set $xxxpassurl http://xxx-test;
                }
            rewrite ^/xxx(.*)$  $1 break;
            proxy_pass $xxxpassurl;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $http_connection;
            proxy_http_version 1.1;
        }  
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 14 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/10/nginx/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/10/nginx/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>云主机磁盘分区</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;去年云主机快到期了，对比各个云主机，挑选性价比最高的一家云主机，最后选了ucloud的，因为确实便宜到爆炸啊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;去年这个时候，薅羊毛2c8g的伦敦节点，花了300+一年搞定&lt;br /&gt;
今年看到官网又出了海外节点2折的活动，果断入手&lt;br /&gt;
香港节点2c4g20G+2M带宽，价格550&lt;/p&gt;

&lt;p&gt;以上与本文无关&lt;br /&gt;
发现系统盘有点小，准备扩一下系统盘，20g到40g一年0.01元，呵呵呵，不买我是弟弟啊~&lt;br /&gt;
一顿操作加载系统盘，重装电脑，发现fdisk下面仅仅/dev/vda显示为40g。系统盘已经挂载上去的/dev/vda1对应系统的/目录仍然是20g&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2019-07-01-mkdisk/mkdisk1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有20g没有划入分区？那就分区呗&lt;/p&gt;

&lt;p&gt;fdisk /dev/vda
n p 2 新建分区-建立分区-分区编号（ucloud默认是2-4）
剩下的默认回车就行了，大概意思是选择盘符的起始位置，结束位置，就是划分磁盘的大小
w  最后w保存创建，退出交互模式&lt;/p&gt;

&lt;p&gt;分区建完，格式化磁盘&lt;br /&gt;
mkfs.ext4 /dev/vda2&lt;br /&gt;
如果报错，则在内核将刚创建的分区更新过去&lt;br /&gt;
partprobe&lt;br /&gt;
再格式化&lt;/p&gt;

&lt;p&gt;最后一步，挂载分区&lt;br /&gt;
mkdir /data (创建任意目录)&lt;br /&gt;
mount /dev/vda2 /data&lt;br /&gt;
&lt;img src=&quot;/images/posts/2019-07-01-mkdisk/mkdisk2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Jul 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/07/mkdisk/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/07/mkdisk/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Openshift-生产环境部署</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;生产环境安装openshift&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;主机类型&lt;/th&gt;
      &lt;th&gt;主机名&lt;/th&gt;
      &lt;th&gt;IP地址&lt;/th&gt;
      &lt;th&gt;操作系统&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Master节点&lt;/td&gt;
      &lt;td&gt;master.example.com&lt;/td&gt;
      &lt;td&gt;192.168.172.168&lt;/td&gt;
      &lt;td&gt;Centos 7.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Node节点&lt;/td&gt;
      &lt;td&gt;node1.example.com&lt;/td&gt;
      &lt;td&gt;192.168.172.169&lt;/td&gt;
      &lt;td&gt;Centos 7.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Node节点&lt;/td&gt;
      &lt;td&gt;node2.example.com&lt;/td&gt;
      &lt;td&gt;192.168.172.170&lt;/td&gt;
      &lt;td&gt;Centos 7.2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;1配置主机名&quot;&gt;1.配置主机名&lt;/h2&gt;

&lt;p&gt;hostnamectl set-hostname master.example.com&lt;br /&gt;
配置相关域名解析，使主机名可解析到对应ip地址&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-host&quot;&gt;192.168.172.168  master.example.com  
192.168.172.169  node1.example.com  
192.168.172.170  node2.example.com  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有节点设置网络&lt;br /&gt;
查看网络链接&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;nmcli con show&lt;/code&gt;
打开链接&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;nmcli con up eth0&lt;/code&gt;&lt;br /&gt;
设置开机自启动&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;nmcli con mod eth0 connection.autoconnect yes&lt;/code&gt;&lt;br /&gt;
重启网络服务&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl restart NetworkManager&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;2安装及配置软件包&quot;&gt;2.安装及配置软件包&lt;/h2&gt;

&lt;p&gt;所有节点安装openshift依赖软件包&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;yum install -y wget git net-tools bind-utils iptables-services bridge-utils bash-completion&lt;/code&gt;&lt;br /&gt;
所有节点安装容器引擎docker&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;yum install -y docker&lt;/code&gt;&lt;br /&gt;
修改配置存储&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;vim /etc/sysconfig/docker-storage-setup&lt;/code&gt;&lt;br /&gt;
添加 ENVS=/dev/sdb
执行docker-storage-setup&lt;/p&gt;

&lt;p&gt;在Master节点启动EPEL安装ansible&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-8.noarch.rpm  
&lt;span class=&quot;nb&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;s/^enabled=1/enabled=0/&quot;&lt;/span&gt; /etc/yum.repos.d/epel.repo  
yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--enablerepo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;epel &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;ansible pyopenSSL  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Master节点生成SSH密钥&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-keygen -f /root/.ssh/id_rsa -N ''&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ansible基于Agentless架构实现，不需要在目标主机安装agent依赖ssh远程控制协议，所以需要配置master和node节点互信&lt;br /&gt;
在Master节点执行：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;host &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;master.example.com &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
node1.example.com &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
node2.example.com&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;ssh-copy-id &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; ~/.ssh/id_rsa.pub &lt;span class=&quot;nv&quot;&gt;$host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Master节点安装Openshift的ansible Playbook&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://github.com/openshift/openshift-ansible/archive/openshift-ansible-3.3.26-1.tar.gz  
&lt;span class=&quot;nb&quot;&gt;tar &lt;/span&gt;zxf openshift-ansible-3.3.26-1.tar.gz  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装单master可以不单独安装etcd,这里选择安装单节点的etcd,生产环境安装3节点的etcd集群,确保高可用&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; etcd  
systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;etcd  
systemctl start etcd  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;配置ansible&quot;&gt;配置ansible&lt;/h2&gt;

&lt;p&gt;备份原有ansible的host&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;cp /etc/ansible/hosts /etc/ansible/hosts-bk&lt;/code&gt;&lt;br /&gt;
修改hosts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-hosts文件&quot;&gt;[OSEv3:children]
masters
nodes
etcd

[OSEv3:vars]
ansible_ssh_user=root
openshift_deployment_type=origin
openshift_release=1.3.0

openshift_master_identity_providers=[{'name': 'htpasswd_auth', 'login': 'true', 'challenge': 'true', 'kind': 'HTPasswdPasswordIdentityProvider', 'filename': '/etc/origin/master/htpasswd'}]

[masters]
openshift-test-master

[nodes]
master.example.com  
node1.example.com  
node2.example.com

[etcd]
openshift-test-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行安装&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ansible-playbook ~/openshift-ansible-3.3.26-1/playbooks/byo/config.yml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;执行完成以后，通过oc get node 查看节点状态&lt;/p&gt;

&lt;p&gt;基础安装完毕以后，进行组件和功能的配置&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对接用户身份信息库&lt;/li&gt;
  &lt;li&gt;导入Image Stream&lt;/li&gt;
  &lt;li&gt;导入Template&lt;/li&gt;
  &lt;li&gt;部署Router&lt;/li&gt;
  &lt;li&gt;部署Registry&lt;/li&gt;
  &lt;li&gt;部署度量收集组件&lt;/li&gt;
  &lt;li&gt;部署日志聚合组件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用户身份信息库：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;openshift_master_identity_providers=[{'name': 'htpasswd_auth', 'login': 'true', 'challenge': 'true', 'kind': 'HTPasswdPasswordIdentityProvider', 'filename': '/etc/origin/master/htpasswd'}]&lt;/code&gt;&lt;br /&gt;
定义了文件/etc/origin/master/htpasswd作为用户身份信息库，我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;htpasswd -b /etc/origin/master/htpasswd dev dev&lt;/code&gt;来创建用户&lt;/p&gt;

&lt;p&gt;is和template用ansible部署时默认已经部署上了&lt;/p&gt;

&lt;p&gt;Router部署&lt;br /&gt;
Router是以容器的形式运行在Openshift平台，默认情况不知道容器运行在哪个node上&lt;br /&gt;
为node打上标签(Label),然后通过节点选择器(NodeSelector)指定容器运行的node&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc label node node1.example.com infra=yes&lt;/code&gt;&lt;br /&gt;
查看node节点&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc get node --show-labels&lt;/code&gt;&lt;br /&gt;
为Router使用的Service Account赋权&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;oadm policy add-scc-to-user privileged system:serviceaccount:default:router
oadm policy add-cluster-role-to-user cluster-reader system:serviceaccount:default:router
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;部署router&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oadm router ose-router --replicas=1 --service-account=router --selector='infra=yes'&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Registry部署&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oadm registry --config='/etc/origin/master/admin.kubeconfig' --service-account=registry --selector='infra=yes' -n default&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看pod&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc get pod -n default|grep registry&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/openshift2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/openshift2/</guid>
        
        <category>Openshift</category>
        
        
      </item>
    
      <item>
        <title>Openshift-测试环境AllInOne</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;记录Openshift笔记，刚准备熟悉一下mysql，boss要求看openshift相关的东西，所以mysql系列的后续再更新，边写openshift边学习沉淀吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;安装openshift-all-in-one&quot;&gt;安装openshift-All in one&lt;/h2&gt;

&lt;p&gt;https://www.clouda.ca/blog/general/openshift-on-centos-7-quick-installation/&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;wget https://github.com/openshift/origin/releases/download/v1.3.0/openshift-origin-server-v1.3.0-3ab7af3d097b57f933eccef684a714f2368804e7-linux-64bit.tar.gz&quot;&gt;二进制下载地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;oc命令行创建应用&quot;&gt;oc命令行创建应用&lt;/h3&gt;

&lt;p&gt;因为oc命令带有权限管控，所以在使用oc命令前，需要通过oc login 登录&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc login -u test https://10.50.64.34:8443&lt;/code&gt;&lt;br /&gt;
创建项目(这个项目类似在k8s创建一个namespace)&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc new-project hello-world-oc&lt;/code&gt;&lt;br /&gt;
部署应用&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc new-app openshift/hello-openshift&lt;/code&gt;&lt;br /&gt;
查看pod&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc get pod&lt;/code&gt;&lt;br /&gt;
查看pod详细信息&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc describe pod hello-openshift-1-z8mki&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;集群管理员账号登录&quot;&gt;集群管理员账号登录&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir -p ~/.kube
cp /opt/openshift/openshift.local.config/master/admin.kubeconfig ~/.kube/config
登录  
oc login -u system:admin
查看集群节点  
oc get node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加route&quot;&gt;添加route&lt;/h3&gt;

&lt;p&gt;类似kube-proxy,是外界访问openshift的入口，外部请求都会到达router&lt;br /&gt;
切换到default项目&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc project default&lt;/code&gt;
router组件需要读取集群的信息，它关联一个系统账号service account并为这个账号赋权。&lt;br /&gt;
(这个账号是专门供程序和组件使用的账号)&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oadm policy add-scc-to-user privileged system:serviceaccount:default:router&lt;/code&gt;
创建router实例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;oadm router router --replicas=1 --service-account=router
oc get pod -n default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加registry&quot;&gt;添加registry&lt;/h3&gt;
&lt;p&gt;集群的docker registry内部docker镜像仓库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;oc project default
oadm registry --config=/opt/openshift/openshift.local.config/master/admin.kubeconfig --service-account=registry
oc get pod  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为registry没有启用https,所以需要修改docker配置，让docker以非https模式连接到registry.&lt;br /&gt;
在OPTIONS变量值中添加参数’–insecure-registry=172.30.0.0/16’&lt;br /&gt;
重启docker systemctl restart docker&lt;/p&gt;

&lt;h3 id=&quot;添加image-stream&quot;&gt;添加Image Stream&lt;/h3&gt;

&lt;p&gt;is镜像集合，openshift并不一定要用到is，is是为了更加方便的将镜像管理和使用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;oc project openshift
openshift version
curl https://raw.githubusercontent.com/openshift/origin/v1.3.0/examples/image-streams/image-streams-centos7.json|oc create -f - -n openshift
oc get is -n openshift
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加template&quot;&gt;添加Template&lt;/h3&gt;

&lt;p&gt;openshift定义了一些template供用户使用，模板定义一个多个部署镜像的集合，定义部署依赖对象以及配置参数项&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;oc project openshift
oc create -f https://raw.githubusercontent.com/openshift/origin/v1.3.0/examples/quickstarts/cakephp-mysql.json -n openshift  
oc get template -n openshift
oc get template cakephp-mysql-example -o json -n openshift
oc create -f https://raw.githubusercontent.com/nichochen/openshift-book-source/master/template/wildfly-basic-s2i.template.json -n openshift  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 20 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/openshift1/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/openshift1/</guid>
        
        <category>Openshift</category>
        
        
      </item>
    
      <item>
        <title>Mysql最佳实践</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;记录mysql读书日记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;安装mysql&quot;&gt;安装mysql&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ curl -LO http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm&lt;/code&gt;
安装 mysql 源&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo yum localinstall mysql57-community-release-el7-11.noarch.rpm&lt;/code&gt;
检查 yum 源是否安装成功&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-a&quot;&gt;
$ sudo yum repolist enabled | grep &quot;mysql.*-community.*&quot;
mysql-connectors-community           MySQL Connectors Community              21
mysql-tools-community                MySQL Tools Community                   38
mysql57-community                    MySQL 5.7 Community Server             130
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上所示，找到了 mysql 的安装包&lt;/p&gt;

&lt;p&gt;2.安装&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo yum install mysql-community-server&lt;/code&gt;
3.启动&lt;/p&gt;

&lt;p&gt;安装服务&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo systemctl enable mysqld&lt;/code&gt;
启动服务&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo systemctl start mysqld&lt;/code&gt;
查看服务状态&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo systemctl status mysqld&lt;/code&gt;
4.修改 root 默认密码&lt;/p&gt;

&lt;p&gt;MySQL 5.7 启动后，在 /var/log/mysqld.log 文件中给 root 生成了一个默认密码。通过下面的方式找到 root 默认密码，然后登录 mysql 进行修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-b&quot;&gt;$ grep 'temporary password' /var/log/mysqld.log
[Note] A temporary password is generated for root@localhost: **********
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登录 MySQL 并修改密码&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Enter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;USER&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'@'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localhost&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDENTIFIED&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyNewPass4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;注意：&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MySQL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;默认安装了密码安全检查插件（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;validate_password&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;位。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过 MySQL 环境变量可以查看密码策略的相关信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-e&quot;&gt;
mysql&amp;gt; SHOW VARIABLES LIKE 'validate_password%';
+--------------------------------------+--------+
| Variable_name                        | Value  |
+--------------------------------------+--------+
| validate_password_check_user_name    | OFF    |
| validate_password_dictionary_file    |        |
| validate_password_length             | 8      |
| validate_password_mixed_case_count   | 1      |
| validate_password_number_count       | 1      |
| validate_password_policy             | MEDIUM |
| validate_password_special_char_count | 1      |
+--------------------------------------+--------+
7 rows in set (0.01 sec)
具体修改，参见 http://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定密码校验策略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-f&quot;&gt;$ sudo vi /etc/my.cnf

[mysqld]
# 添加如下键值对, 0=LOW, 1=MEDIUM, 2=STRONG
validate_password_policy=0
禁用密码策略

$ sudo vi /etc/my.cnf
	
[mysqld]
# 禁用密码校验策略
validate_password = off
重启 MySQL 服务，使配置生效

$ sudo systemctl restart mysqld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.添加远程登录用户&lt;/p&gt;

&lt;p&gt;MySQL 默认只允许 root 帐户在本地登录，如果要在其它机器上连接 MySQL，必须修改 root 允许远程连接，或者添加一个允许远程连接的帐户，为了安全起见，本例添加一个新的帐户：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&amp;gt; GRANT ALL PRIVILEGES ON *.* TO 'admin'@'%' IDENTIFIED BY 'secret' WITH GRANT OPTION;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;6.配置默认编码为 utf8&lt;/p&gt;

&lt;p&gt;MySQL 默认为 latin1, 一般修改为 UTF-8&lt;/p&gt;

&lt;p&gt;$ vi /etc/my.cnf
[mysqld]&lt;/p&gt;
&lt;h1 id=&quot;在myslqd下添加如下键值对&quot;&gt;在myslqd下添加如下键值对&lt;/h1&gt;
&lt;p&gt;character_set_server=utf8
init_connect=’SET NAMES utf8’
重启 MySQL 服务，使配置生效&lt;/p&gt;

&lt;p&gt;$ sudo systemctl restart mysqld
查看字符集&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; SHOW VARIABLES LIKE ‘character%’;
+————————–+—————————-+
| Variable_name            | Value                      |
+————————–+—————————-+
| character_set_client     | utf8                       |
| character_set_connection | utf8                       |
| character_set_database   | utf8                       |
| character_set_filesystem | binary                     |
| character_set_results    | utf8                       |
| character_set_server     | utf8                       |
| character_set_system     | utf8                       |
| character_sets_dir       | /usr/share/mysql/charsets/ |
+————————–+—————————-+
8 rows in set (0.00 sec
7.开启端口&lt;/p&gt;

&lt;p&gt;$ sudo firewall-cmd –zone=public –add-port=3306/tcp –permanent
$ sudo firewall-cmd –reload&lt;/p&gt;

&lt;p&gt;简易方式快速启动：
宿主机
curl -LO http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm
yum install mysql-community-client -y&lt;/p&gt;

&lt;p&gt;yum install  docker docker-compose -y&lt;/p&gt;

&lt;p&gt;mkdir -p /mysql
mkdir -p /mysql/data
mkdir -p /mysql/config&lt;/p&gt;

&lt;p&gt;将my.conf复制到/mysql/config下
将docker-compose.yml拷贝到/mysql下&lt;/p&gt;

&lt;p&gt;my.cnf配置如下（.cnf结尾）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-my.cnf&quot;&gt;# The MySQL database server configuration file.
#
# You can copy this to one of:
# - &quot;/etc/mysql/my.cnf&quot; to set global options,
# - &quot;~/.my.cnf&quot; to set user-specific options.
#
# One can use all long options that the program supports.
# Run program with --help to get a list of available options and with
# --print-defaults to see which it would actually understand and use.
#
# For explanations see
# http://dev.mysql.com/doc/mysql/en/server-system-variables.html

# This will be passed to all mysql clients
# It has been reported that passwords should be enclosed with ticks/quotes
# escpecially if they contain &quot;#&quot; chars...
# Remember to edit /etc/mysql/debian.cnf when changing the socket location.

# Here is entries for some specific programs
# The following values assume you have at least 32M ram

[mysqld_safe]
socket		= /var/run/mysqld/mysqld.sock
nice		= 0

[mysqld]
#
# * Basic Settings
#
user		= mysql
pid-file	= /var/run/mysqld/mysqld.pid
socket		= /var/run/mysqld/mysqld.sock
port		= 3306
basedir		= /usr
datadir		= /var/lib/mysql
tmpdir		= /tmp
lc-messages-dir	= /usr/share/mysql
skip-external-locking
skip-grant-tables
#
# Instead of skip-networking the default is now to listen only on
# localhost which is more compatible and is not less secure.
bind-address		= 0.0.0.0
#
# * Fine Tuning
#
key_buffer_size		= 16M
max_allowed_packet	= 16M
thread_stack		= 192K
thread_cache_size       = 8
# This replaces the startup script and checks MyISAM tables if needed
# the first time they are touched
myisam-recover-options  = BACKUP
#max_connections        = 100
#table_cache            = 64
#thread_concurrency     = 10
#
# * Query Cache Configuration
#
query_cache_limit	= 1M
query_cache_size        = 16M
#
# * Logging and Replication
#
# Both location gets rotated by the cronjob.
# Be aware that this log type is a performance killer.
# As of 5.1 you can enable the log at runtime!
#general_log_file        = /var/log/mysql/mysql.log
#general_log             = 1
#
# Error log - should be very few entries.
#
log_error = /var/log/mysql/error.log
#
# Here you can see queries with especially long duration
#log_slow_queries	= /var/log/mysql/mysql-slow.log
#long_query_time = 2
#log-queries-not-using-indexes
#
# The following can be used as easy to replay backup logs or for replication.
# note: if you are setting up a replication slave, see README.Debian about
#       other settings you may need to change.
#server-id		= 1
#log_bin			= /var/log/mysql/mysql-bin.log
expire_logs_days	= 10
max_binlog_size   = 100M
#binlog_do_db		= include_database_name
#binlog_ignore_db	= include_database_name
#
# * InnoDB
#
# InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.
# Read the manual for more InnoDB related options. There are many!
#
# * Security Features
#
# Read the manual, too, if you want chroot!
# chroot = /var/lib/mysql/
#
# For generating SSL certificates I recommend the OpenSSL GUI &quot;tinyca&quot;.
#
# ssl-ca=/etc/mysql/cacert.pem
# ssl-cert=/etc/mysql/server-cert.pem
# ssl-key=/etc/mysql/server-key.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker-compose文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-compose&quot;&gt;version: '3'
services:
  mysql:
    image: mysql:5.7
    container_name: mysql
    command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci #设置utf8字符集
    restart: always
    ports:
      - 6606:3306
    volumes:
      - &quot;/mysql/data:/var/lib/mysql&quot;
      - &quot;/mysql/config:/etc/mysql/conf.d&quot;
    environment:
      MYSQL_ROOT_PASSWORD: &quot;123456&quot;   #root管理员用户密码
      MYSQL_USER: test   #创建test用户
      MYSQL_PASSWORD: test  #设置test用户的密码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker-compose up -d 启动&lt;br /&gt;
宿主机登录mysql: mysql -uroot -P6606 -p -h127.0.0.1&lt;/p&gt;

&lt;p&gt;报错&lt;code class=&quot;highlighter-rouge&quot;&gt;Access denied for user 'root'@'localhost' (using password: YES)&lt;/code&gt;
配置文件添加：skip-grant-tables
进入数据量，更新密码update mysql.user set authentication_string=password(‘&lt;strong&gt;**&lt;/strong&gt;&lt;em&gt;’) where user=’&lt;/em&gt;&lt;strong&gt;**&lt;/strong&gt;’&lt;/p&gt;

</description>
        <pubDate>Mon, 14 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/learnmysql/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/learnmysql/</guid>
        
        <category>Mysql</category>
        
        
      </item>
    
      <item>
        <title>Linux常用快捷键【持续更新...】</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;一些好用的命令每次要用的时候，不记得怎么用，用起来时区网上查找。死循环，决定整理一份自己常用且好用的一些整理，梳理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;vim快捷键&quot;&gt;Vim快捷键&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;文档操作&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:e!&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;重新加载当前文档，并丢弃已做的改动&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:f newname&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;相当于复制一个文件到新名字&lt;/td&gt;
      &lt;td&gt;保存退出则相当于创建一个新的文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;光标屏幕移动&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;k/j/h/l&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上下左右&lt;/td&gt;
      &lt;td&gt;作用和方向键左右一致&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SHIFT+e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;光标移动下一个字符串的结尾&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SHIFT+h/m/l&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;光标移动当前窗口的首，中，尾&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zz&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;屏幕当前行至于屏幕中间&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL+y/e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;屏幕上下滚动&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SHIFT+e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;屏幕移动下一个字符串的结尾&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;编辑操作&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;u&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;撤销&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;光标向后删除&lt;/td&gt;
      &lt;td&gt;光标向前：X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yn&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;当前光标向下复制n行&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;光标向后删除字符&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;向前删除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;重复前一个动作&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:vs xx/xx/file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;垂直分屏打开文件file&lt;/td&gt;
      &lt;td&gt;切换屏幕ctrl+w+w这个切换屏幕同样适用vimdiff&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:sp xx/xx/file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;水平分屏打开文件file&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:!command&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;暂时离开vi，到命令行下执行命令&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;编程相关&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ci&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;修改”内的内容&lt;/td&gt;
      &lt;td&gt;相当于di”+i,实用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;多行操作&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;ctrl+v选择编辑的列，shift+i编辑，esc&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;linux常用快捷键&quot;&gt;Linux常用快捷键&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;常用命令&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;–命令行快捷键–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+k&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;剪切(删除)光标到行尾的字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+u&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;剪切(删除)光标到行首的字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+w&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;剪切(删除)光标前一个单词&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+y&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;粘贴k,u,w的字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esc+b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动光标到当前单词的开头&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esc+f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动光标到当前单词的结尾&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–ls&amp;amp;ll–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;按时间排序，最新在最前面&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -rt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;按时间倒序排序，最新在最后面&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–去重–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uniq&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;文件去重行或用&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;传替，注意是按行去重&lt;/td&gt;
      &lt;td&gt;eg: &lt;code class=&quot;highlighter-rouge&quot;&gt;cat file|sort|uniq -c&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;linux-一些命令&quot;&gt;Linux 一些命令&lt;/h3&gt;

&lt;p&gt;变量=a,文件=file&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Command&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;–文件处理–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sed -i '/^$/d' file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;清除文件所有空白的行&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sed -i '/#/d'  file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;清除文件中所有包含某字符的行，以#为例&lt;/td&gt;
      &lt;td&gt;//中间支持正则,比如删除以#开头则^#&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–字符处理–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if [[ $a =~ ':' ]]&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;判断字符串中是否包含某字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a#*.}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中第一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其左边的字符&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=2.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a##*.}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中最后一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其左边的字符&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a%.*}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中最后一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其右边的字符串&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=1.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a%%.*}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其右边的字符串&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:0:$}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;取字符串第一到最后一个字符&lt;/td&gt;
      &lt;td&gt;eg: ${a:1:2} a=1234 -&amp;gt; a=23&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a/b/c}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将a字符串中的第一个b字符替换成c字符&lt;/td&gt;
      &lt;td&gt;eg: ${a/2/3} a=1232 -&amp;gt; a=1332&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a//b/c}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将a字符串中的所有b字符替换成c字符&lt;/td&gt;
      &lt;td&gt;eg: ${a/2/3} a=1232 -&amp;gt; a=1333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${#a}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;返回一个整数值，数值为字符串长度&lt;/td&gt;
      &lt;td&gt;eg: a=123 echo ${#a} -&amp;gt; 3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a-b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:-b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值或空，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a+b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a空或非空，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:+b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a非空，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a=b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值，则使用b为返回值,并赋值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:=b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值或空，则使用b为返回值，并赋值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Thu, 27 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/useful/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/useful/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Redis集群下生产实践</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;背景：近期弄了一套集群环境的服务，其中包含mongo数据库集群，redis集群和其他的服务集群，高可用的架构，为了支持真正意义的高可用，而做了这篇博客&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;集群高可用&quot;&gt;集群高可用&lt;/h3&gt;

&lt;p&gt;以6节点三主三从为例&lt;br /&gt;
cluster-enabled指定启动集群模式&lt;br /&gt;
cluster-config-file指定保存节点配置的文件，redis集群启动后会自动创建修改维护这些nodes.conf文件&lt;/p&gt;

&lt;p&gt;集群模式的最简节点配置文件如下&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;port 7000
cluster-enabled &lt;span class=&quot;nb&quot;&gt;yes
&lt;/span&gt;cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly &lt;span class=&quot;nb&quot;&gt;yes&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以添加一些配置指定数据文件，日志等&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pidfile /var/run/redis/redis.pid
&lt;span class=&quot;nb&quot;&gt;bind &lt;/span&gt;127.0.0.1 xxx.xxx.xxx.xxx
loglevel notice
logfile /xxx/log/redis/redis.log
&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt; /xxx/db/redis/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外还有一些配置，例如负载很大的服务修改&lt;strong&gt;tcp-backlog、tcp-keepalive&lt;/strong&gt;参数等&lt;/p&gt;

&lt;p&gt;按上面方法，通过修改监听端口启动的不同节点的redis实例，但还不是集群&lt;br /&gt;
&lt;strong&gt;redis-trib 位于Redis源码的src文件夹中,它是一个Ruby程序&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./redis-trib.rb create &lt;span class=&quot;nt&quot;&gt;--replicas&lt;/span&gt; 1  ip1:port1 ip2:port2 ip3:port3 ip4:port4 ip5:port5 ip6:port6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;replicas 1&lt;/code&gt;这个参数指定在6个节点中为每个主节点创建一个从节点，则执行完后会生成对应的三主三从节点配置。&lt;/p&gt;

&lt;h3 id=&quot;哨兵高可用&quot;&gt;哨兵高可用&lt;/h3&gt;

&lt;p&gt;以一主两从三节点介绍&lt;br /&gt;
redis节点的默认配置文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis-default.conf&quot;&gt;daemonize yes
pidfile /var/run/redis/redis.pid
port 6379
tcp-backlog 2048
bind 127.0.0.1 xxx.xxx.xxx.xxx
timeout 0
tcp-keepalive 60
loglevel notice
logfile /xxx/xxx/redis.log
databases 16
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir /xxx/xxx/redis/
slave-serve-stale-data yes
slave-read-only yes
repl-disable-tcp-nodelay no
slave-priority 100
appendonly no
appendfilename &quot;appendonly.aof&quot;
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
lua-time-limit 5000
slowlog-log-slower-than 10000
slowlog-max-len 128
latency-monitor-threshold 0
notify-keyspace-events &quot;&quot;
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-entries 512
list-max-ziplist-value 64
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果加密的话&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis加密&quot;&gt;requirepass  xxxxx  　　#设置redis登录密码
masterauth   xxxxx　　  #主从认证密码，否则主从不能同步
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一主两从，主节点使用上面默认配置启动&lt;br /&gt;
从节点在主节点配置基础上增加一条&lt;code class=&quot;highlighter-rouge&quot;&gt;slaveof 127.0.0.1 6380&lt;/code&gt;  其中ip和端口写主节点的ip和端口&lt;br /&gt;
entinel 哨兵(执行文件和redis-server同目录下)&lt;br /&gt;
每个节点创建一个sentinel.conf文件，在默认的配置上只需修改port,其他的配置三个节点保持一致&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sentinel-default.conf&quot;&gt;port 26379
dir /tmp  
sentinel monitor mymaster 192.168.248.131 6379 2  
sentinel down-after-milliseconds mymaster 30000  
sentinel parallel-syncs mymaster 1  
sentinel failover-timeout mymaster 180000  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果redis需要密码的话加上auth-pass&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis加密&quot;&gt;sentinel auth-pass mymaster xxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动redis主从和哨兵
&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-server redis.conf &amp;amp;&lt;/code&gt;(如果不在一个文件夹下注意路径)&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-sentinel sentinel.conf &amp;amp;&lt;/code&gt;启动sentinel&lt;/p&gt;

&lt;h3 id=&quot;集群高可用和哨兵高可用对比&quot;&gt;集群高可用和哨兵高可用对比&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;单节点&lt;/th&gt;
      &lt;th&gt;集群模式&lt;/th&gt;
      &lt;th&gt;哨兵模式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;运作模式&lt;/td&gt;
      &lt;td&gt;单节点，宕机则停止服务&lt;/td&gt;
      &lt;td&gt;无中心节点，多节点服务&lt;/td&gt;
      &lt;td&gt;由哨兵处理故障转移存在性能瓶颈&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;分片&lt;/td&gt;
      &lt;td&gt;单实例&lt;/td&gt;
      &lt;td&gt;按槽分配，每个节点分配不同的槽，控制每个节点的请求和数据量&lt;/td&gt;
      &lt;td&gt;每个主分担1/N&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可用性&lt;/td&gt;
      &lt;td&gt;无容错性&lt;/td&gt;
      &lt;td&gt;集群节点内置了高可用和复制性能&lt;/td&gt;
      &lt;td&gt;配置sentinel实现复制和高可用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;

&lt;p&gt;还存在一个问题，如果程序中写死了写缓存的地址，但是当masterdown掉之后新的master的地址可能是发生变化的，所以此时我们需要keepalived来实现地址的漂移。&lt;br /&gt;
看到过一遍关于这个方法的解决方案是基于sentinel的keepalived&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/huangyimo/article/details/76618532&quot;&gt;哨兵+keepalived，请参考&lt;/a&gt;&lt;br /&gt;
参考方法中也提到了局限性，包括不受控网络以及云主机环境，无法提供虚拟ip等情况&lt;/p&gt;

&lt;p&gt;这里可通过脚本的方法解决程序缓存地址的问题,能解决没有虚拟ip以及不可控网络的方法&lt;br /&gt;
同样，这个方法无论是集群模式的redis和哨兵模式的redis,都适用&lt;br /&gt;
脚本填入redis节点的ip，并在本地的hosts写入redis解析地址(如果是多master节点，可以改写一下脚本)&lt;br /&gt;
脚本每2秒检测一次当前集群的master，如果master连接不上或者变了，那么脚本会直接替换掉解析中的ip&lt;br /&gt;
程序如果还不能正常，脚本还可以加入重启服务的部分。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#要求1: /etc/hosts里面写入 &quot;1.1.1.1 redis-tb&quot; 的解析规则&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#要求2: 该脚本要有读写/etc/hosts的权限，建议用root&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;hostlist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'1.1.1.1'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2.2.2.2'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'3.3.3.3'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;
checkismaster&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;3 &lt;span class=&quot;nv&quot;&gt;ismaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;info |timeout 2 redis-cli &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'role'&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;':'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{print $2}'&lt;/span&gt;|grep &lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;master&quot;&lt;/span&gt;|wc &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ismaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ismaster&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;then
     &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;nowhost is master&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else
   &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;nowhost not master&quot;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1
  &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do
  &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;nowhost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/hosts | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'redis-tb'&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{print $1}'&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
  checkismaster &lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$flag&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;i &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;hostlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[@]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;do
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;now is finding master in hostlist&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;checking ip --  &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;3 &lt;span class=&quot;nv&quot;&gt;checkmaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;info |timeout 2 redis-cli &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'role'&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;':'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{print $2}'&lt;/span&gt;|grep &lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;master&quot;&lt;/span&gt;|wc &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;checkmaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;when checkip is master, then checkmaster=1 ---  &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$checkmaster&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$checkmaster&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;then
     &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;now changeing nowhost to master = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; to &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
     &lt;span class=&quot;nb&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'s/'&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/g'&lt;/span&gt; /etc/hosts
    &lt;span class=&quot;k&quot;&gt;fi
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
   &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;sleep &lt;/span&gt;2
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nohup sh xx.sh &amp;amp;&lt;br /&gt;
将脚本放后台执行，这个脚本会将三个节点的主写到hosts中，并且每两秒检测一次，在应用中写上hosts指定的master地址&lt;/p&gt;

&lt;h3 id=&quot;附件1redis配置详解&quot;&gt;附件1：redis配置详解&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis配置详解&quot;&gt;# Redis configuration file example.
# ./redis-server /path/to/redis.conf

################################## INCLUDES ###################################
#这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。
# include /path/to/local.conf
# include /path/to/other.conf

################################ GENERAL #####################################

#是否在后台执行，yes：后台运行；no：不是后台运行（老版本默认）
daemonize yes

  #3.2里的参数，是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码   和bind，可以开启。否   则最好关闭，设置为no。
  protected-mode yes
#redis的进程文件
pidfile /var/run/redis/redis-server.pid

#redis监听的端口号。
port 6379

#此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的/proc/sys/net/core/somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。在/etc/sysctl.conf中添加:net.core.somaxconn = 2048，然后在终端中执行sysctl -p。
tcp-backlog 511

#指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求
bind 127.0.0.1

#配置unix socket来让redis支持监听本地连接。
# unixsocket /var/run/redis/redis.sock
#配置unix socket使用文件的权限
# unixsocketperm 700

# 此参数为设置客户端空闲超过timeout，服务端会断开连接，为0则服务端不会主动断开连接，不能小于0。
timeout 0

#tcp keepalive参数。如果设置不为0，就使用配置tcp的SO_KEEPALIVE值，使用keepalive有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在Linux内核中，设置了keepalive，redis会定时给对端发送ack。检测到对端关闭需要两倍的设置值。
tcp-keepalive 0

#指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的信息，但是没有debug级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息）
loglevel notice

#指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的redis标准输出是/dev/null。
logfile /var/log/redis/redis-server.log

#是否打开记录syslog功能
# syslog-enabled no

#syslog的标识符。
# syslog-ident redis

#日志的来源、设备
# syslog-facility local0

#数据库的数量，默认使用的数据库是DB 0。可以通过”SELECT “命令选择一个db
databases 16

################################ SNAPSHOTTING ################################
# 快照配置
# 注释掉“save”这一行配置项就可以让保存数据库功能失效
# 设置sedis进行数据库镜像的频率。
# 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） 
# 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） 
# 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）
save 900 1
save 300 10
save 60 10000

#当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误
stop-writes-on-bgsave-error yes

#使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间
rdbcompression yes

#是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。
rdbchecksum yes

#rdb文件的名称
dbfilename dump.rdb

#数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录
dir /var/lib/redis

################################# REPLICATION #################################
#复制选项，slave复制对应的master。
# slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;

#如果master设置了requirepass，那么slave要连上master，需要有master的密码才行。masterauth就是用来配置master的密码，这样可以在连上master后进行认证。
# masterauth &amp;lt;master-password&amp;gt;

#当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data设置为no，除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master in progress”。
slave-serve-stale-data yes

#作为从服务器，默认情况下是只读的（yes），可以修改成NO，用于写（不建议）。
slave-read-only yes

#是否使用socket方式复制数据。目前redis复制提供两种方式，disk和socket。如果新的slave连上来或者重连的slave无法部分同步，就会执行全量同步，master会生成rdb文件。有2种方式：disk方式是master创建一个新的进程把rdb文件保存到磁盘，再把磁盘上的rdb文件传递给slave。socket是master创建一个新的进程，直接把rdb文件以socket的方式发给slave。disk方式的时候，当一个rdb保存的过程中，多个slave都能共享这个rdb文件。socket的方式就的一个个slave顺序复制。在磁盘速度缓慢，网速快的情况下推荐用socket方式。
repl-diskless-sync no

#diskless复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。所以最好等待一段时间，等更多的slave连上来。
repl-diskless-sync-delay 5

#slave根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。
# repl-ping-slave-period 10

#复制连接超时时间。master和slave都有超时时间的设置。master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。需要注意的是repl-timeout需要设置一个比repl-ping-slave-period更大的值，不然会经常检测到超时。
# repl-timeout 60

#是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。
repl-disable-tcp-nodelay no

#复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有slave的一段时间，内存会被释放出来，默认1m。
# repl-backlog-size 5mb

#master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。
# repl-backlog-ttl 3600

#当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。而配置成0，永远不会被选举。
slave-priority 100

#redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。
# min-slaves-to-write 3

#延迟小于min-slaves-max-lag秒的slave才认为是健康的slave。
# min-slaves-max-lag 10

# 设置1或另一个设置为0禁用这个特性。
# Setting one or the other to 0 disables the feature.
# By default min-slaves-to-write is set to 0 (feature disabled) and
# min-slaves-max-lag is set to 10.

################################## SECURITY ###################################
#requirepass配置可以让用户使用AUTH命令来认证密码，才能使用其他命令。这让redis可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证。使用requirepass的时候需要注意，因为redis太快了，每秒可以认证15w次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码。
# requirepass foobared

#把危险的命令给修改成其他名称。比如CONFIG命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用。
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52

#设置成一个空的值，可以禁止一个命令
# rename-command CONFIG &quot;&quot;
################################### LIMITS ####################################

# 设置能连上redis的最大客户端连接数量。默认是10000个客户端连接。由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32。如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接。
# maxclients 10000

#redis配置的最大内存容量。当内存满了，需要配合maxmemory-policy策略进行处理。注意slave的输出缓冲区是不计算在maxmemory内的。所以为了防止主机内存使用完，建议设置的maxmemory需要更小一些。
# maxmemory &amp;lt;bytes&amp;gt;

#内存容量超过maxmemory后的处理策略。
#volatile-lru：利用LRU算法移除设置过过期时间的key。
#volatile-random：随机移除设置过过期时间的key。
#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）
#allkeys-lru：利用LRU算法移除任何key。
#allkeys-random：随机移除任何key。
#noeviction：不移除任何key，只是返回一个写错误。
#上面的这些驱逐策略，如果redis没有合适的key驱逐，对于写命令，还是会返回错误。redis将不再接收写请求，只接收get请求。写命令包括：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sort。
# maxmemory-policy noeviction

#lru检测的样本数。使用lru或者ttl淘汰算法，从需要淘汰的列表中随机选择sample个key，选出闲置时间最长的key移除。
# maxmemory-samples 5

############################## APPEND ONLY MODE ###############################
#默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。
appendonly no

#aof文件名
appendfilename &quot;appendonly.aof&quot;

#aof持久化策略的配置
#no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。
#always表示每次写入都执行fsync，以保证数据同步到磁盘。
#everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。
appendfsync everysec

# 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。
no-appendfsync-on-rewrite no

#aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。
auto-aof-rewrite-percentage 100
#设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写
auto-aof-rewrite-min-size 64mb

#aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。
aof-load-truncated yes

################################ LUA SCRIPTING ###############################
# 如果达到最大时间限制（毫秒），redis会记个log，然后返回error。当一个脚本超过了最大时限。只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。要是已经调用了write，只能用第二个命令杀。
lua-time-limit 5000

################################ REDIS CLUSTER ###############################
#集群开关，默认是不开启集群模式。
# cluster-enabled yes

#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突
# cluster-config-file nodes-6379.conf

#节点互连超时的阀值。集群节点超时毫秒数
# cluster-node-timeout 15000

#在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：
#比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period
#如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移 
# cluster-slave-validity-factor 10

#master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。
# cluster-migration-barrier 1

#默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。
# cluster-require-full-coverage yes

################################## SLOW LOG ###################################
###slog log是用来记录redis运行中执行比较慢的命令耗时。当命令的执行超过了指定时间，就记录在slow log中，slog log保存在内存中，所以没有IO操作。
#执行时间比slowlog-log-slower-than大的请求记录到slowlog里面，单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。
slowlog-log-slower-than 10000

#慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。
slowlog-max-len 128

################################ LATENCY MONITOR ##############################
#延迟监控功能是用来监控redis中执行比较缓慢的一些操作，用LATENCY打印redis实例在跑命令时的耗时图表。只记录大于等于下边设置的值的操作。0的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置。
latency-monitor-threshold 0

############################# EVENT NOTIFICATION ##############################
#键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。
#notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：
##K 键空间通知，所有通知以 __keyspace@__ 为前缀
##E 键事件通知，所有通知以 __keyevent@__ 为前缀
##g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知
##$ 字符串命令的通知
##l 列表命令的通知
##s 集合命令的通知
##h 哈希命令的通知
##z 有序集合命令的通知
##x 过期事件：每当有过期键被删除时发送
##e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送
##A 参数 g$lshzxe 的别名
#输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。详细使用可以参考http://redis.io/topics/notifications

notify-keyspace-events &quot;&quot;

############################### ADVANCED CONFIG ###############################
#数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplist-entries用hash
hash-max-ziplist-entries 512
#value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用hash。
hash-max-ziplist-value 64

#数据量小于等于list-max-ziplist-entries用ziplist，大于list-max-ziplist-entries用list。
list-max-ziplist-entries 512
#value大小小于等于list-max-ziplist-value的用ziplist，大于list-max-ziplist-value用list。
list-max-ziplist-value 64

#数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用set。
set-max-intset-entries 512

#数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset。
zset-max-ziplist-entries 128
#value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset。
zset-max-ziplist-value 64

#value大小小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse），大于hll-sparse-max-bytes使用稠密的数据结构（dense）。一个比16000大的value是几乎没用的，建议的value大概为3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右。
hll-sparse-max-bytes 3000

#Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存。
activerehashing yes

##对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。
#对于normal client，第一个0表示取消hard limit，第二个0和第三个0表示取消soft limit，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的。
client-output-buffer-limit normal 0 0 0
#对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过64mb持续60秒，那么服务器就会立即断开客户端连接。
client-output-buffer-limit slave 256mb 64mb 60
#对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么服务器就会立即断开客户端连接。
client-output-buffer-limit pubsub 32mb 8mb 60

#redis执行任务的频率为1s除以hz。
hz 10

#在aof重写的时候，如果打开了aof-rewrite-incremental-fsync开关，系统会每32MB执行一次fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值。
aof-rewrite-incremental-fsync yes
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;附件2哨兵配置详解&quot;&gt;附件2：哨兵配置详解&lt;/h3&gt;

&lt;p&gt;sentinel.conf配置介绍-&lt;a href=&quot;原文：https://blog.csdn.net/u012441222/article/details/80751390&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;# Example sentinel.conf  
# 哨兵sentinel实例运行的端口 默认26379  
port 26379  

# 哨兵sentinel的工作目录  
dir /tmp  

# 哨兵sentinel监控的redis主节点的 ip port  
# master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。  
# quorum 指定多少个哨兵认为master失联时，确认主节点失联，开始主节点飘移  
# sentinel monitor &amp;lt;master-name&amp;gt; &amp;lt;ip&amp;gt; &amp;lt;redis-port&amp;gt; &amp;lt;quorum&amp;gt;  
  sentinel monitor mymaster 127.0.0.1 6379 2  
  
# 当在Redis实例中开启了授权密码，这样所有连接Redis实例的客户端都要提供密码  
# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码  
# sentinel auth-pass &amp;lt;master-name&amp;gt; &amp;lt;password&amp;gt;  
sentinel auth-pass mymaster MySUPER--secret-0123passw0rd  
  
# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒  
# sentinel down-after-milliseconds &amp;lt;master-name&amp;gt; &amp;lt;milliseconds&amp;gt;  
sentinel down-after-milliseconds mymaster 30000  
  
# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，  
这个数字越小，完成failover所需的时间就越长，  
但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。  
可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。  
# sentinel parallel-syncs &amp;lt;master-name&amp;gt; &amp;lt;numslaves&amp;gt;  
sentinel parallel-syncs mymaster 1  
  
# 故障转移的超时时间 failover-timeout 可以用在以下这些方面：  
#1. 同一个sentinel对同一个master两次failover之间的间隔时间。  
#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。  
#3.当想要取消一个正在进行的failover所需要的时间。  
#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了  
# 默认三分钟  
# sentinel failover-timeout &amp;lt;master-name&amp;gt; &amp;lt;milliseconds&amp;gt;  
sentinel failover-timeout mymaster 180000  
  
# SCRIPTS EXECUTION  
#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。  
#对于脚本的运行结果有以下规则：  
#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10  
#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。  
#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。  
#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。  
  
#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，  
这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，  
一个是事件的类型，  
一个是事件的描述。  
如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。  
#通知脚本  
# sentinel notification-script &amp;lt;master-name&amp;gt; &amp;lt;script-path&amp;gt;  
  sentinel notification-script mymaster /var/redis/notify.sh  
  
# 客户端重新配置主节点参数脚本  
# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。  
# 以下参数将会在调用脚本时传给脚本:  
# &amp;lt;master-name&amp;gt; &amp;lt;role&amp;gt; &amp;lt;state&amp;gt; &amp;lt;from-ip&amp;gt; &amp;lt;from-port&amp;gt; &amp;lt;to-ip&amp;gt; &amp;lt;to-port&amp;gt;  
# 目前&amp;lt;state&amp;gt;总是“failover”,  
# &amp;lt;role&amp;gt;是“leader”或者“observer”中的一个。  
# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的  
# 这个脚本应该是通用的，能被多次调用，不是针对性的。  
# sentinel client-reconfig-script &amp;lt;master-name&amp;gt; &amp;lt;script-path&amp;gt;  
 sentinel client-reconfig-script mymaster /var/redis/reconfig.sh  
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 18 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/redis/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/redis/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
  </channel>
</rss>
