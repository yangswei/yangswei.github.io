<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杨世威</title>
    <description>欢迎来到我的个人站~</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 14 Nov 2019 22:04:03 +0800</pubDate>
    <lastBuildDate>Thu, 14 Nov 2019 22:04:03 +0800</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>如何将服务运行在k8s中</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;距离上次更新正好一个月，因为公司马上要搬家了，最近各种环境的迁移，进公司以后除了负责线上的运维还需要分出精力去搞公司的私有客户,最近终于从私有客户那边抽出来，全心投入到公有云的线上运维来了！开始找俊奇大佬要一些简单的需求，写一写接口，多写写抓紧入门一下，这篇文章算是应用容器化+k8s上线的入门教程了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;如何将服务运行在k8s中&quot;&gt;如何将服务运行在k8s中&lt;/h1&gt;

&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;

&lt;p&gt;这篇文章建立在，已经准备好了如下的环境的基础上，如果没有可以找找教程，自行测试k8s太重的话可以弄轻量的k3s都可以&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;python3，docker&lt;/li&gt;
  &lt;li&gt;k8s，私有仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;开发过程&quot;&gt;开发过程&lt;/h3&gt;

&lt;p&gt;因为刚写python，所以这里以python的代码为例，其他语言的均类似&lt;br /&gt;
下面是简单的Hello world进程，程序默认的监听端口是8080&lt;br /&gt;
（当然在我们生产上会有很多复杂的场景，这里只介绍基本情况，就是服务只监听一个端口的情形）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-app.py&quot;&gt;from flask import Flask
app = Flask(__name__)

@app.route(&quot;/&quot;)
def hello():
    return &quot;Hello world!&quot;

if __name__ == &quot;__main__&quot;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;容器化&quot;&gt;容器化&lt;/h3&gt;

&lt;p&gt;接下来就是怎么将各种语言写的代码容器化的操作了&lt;br /&gt;
以python为例,dockerfile很简单&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; python:3.6.4&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; /code &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;apt-get update &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;freetds-dev &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;unixodbc-dev
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; . /code &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; requirements.txt /code&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;pip &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; /code/requirements.txt &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; https://pypi.douban.com/simple
&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; /code&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; [&quot;python3&quot;,&quot;/code/xx.py&quot;,&quot;8060&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FROM一个基础环境，如果你是node开发from一个node的镜像作为基础环境&lt;br /&gt;
RUN 是构建镜像过程中执行指令，这里是运行安装一些基础依赖，这个根据应用来&lt;br /&gt;
基础依赖安装完成后，将代码，以及python依赖的库安装一下&lt;br /&gt;
CMD 则是运行这个容器的最后一条命令&lt;/p&gt;

&lt;p&gt;实际生产环境会要求镜像包最小化&lt;br /&gt;
有一些基础的技巧，可以使最终生成的包大小减少很多。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;dockerfile每条命令相当于在基础镜像上包了一层，所以用连接符减少指令行数&lt;/li&gt;
  &lt;li&gt;multistage builds 这个很好用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面以实际生产中multistage为例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mutidockerfile&quot;&gt;  FROM xxx/node:6.11.2 AS builder
  WORKDIR /app
  COPY package.json ./package.json
  COPY yarn.lock ./
  RUN yarn install  &amp;amp;&amp;amp; yarn cache clean
  FROM node:6.11.2
  WORKDIR /xxx
  COPY --from=builder /xxx/node_modules /xxx/node_modules
  COPY . .
  EXPOSE 5000
  CMD npm start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生产中尽量把构建过程拆分开，最终镜像只需要从过程镜像获取构建好的依赖&lt;/p&gt;

&lt;h3 id=&quot;私有仓库&quot;&gt;私有仓库&lt;/h3&gt;

&lt;p&gt;这里不过多介绍，镜像推送私有仓库很简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmd&quot;&gt;docker build -t xxx:v0.0.1 .  
docker push xxxx:v0.0.1  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;kubernetes创建应用&quot;&gt;kubernetes创建应用&lt;/h3&gt;

&lt;p&gt;下面我先附上deploy文件,再介绍下里面的内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-deployment&quot;&gt;apiVersion: v1
kind: Service
metadata:
  name: xxx(应用名)
  namespace: release(namespace名)
  labels:
    app: xxx(应用名)
    service: xxx(应用名)
spec:
  ports:
  - port: 8060
    name: http
  selector:
    app: xxx(应用名)
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: xxx(应用名)
  namespace: release(namespace名)
  labels:
    app: xxx(应用名)
    version: v1
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: xxx(应用名)
        version: v1
    spec:
      containers:
      - name: xxx(应用名)
        image: xxx:v0.0.1(这里是我们刚推送到私有仓库的地址)
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8060
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我创建了两个资源，kind分别是service和deployment&lt;br /&gt;
service用于将port映射出去&lt;br /&gt;
deployment描述pod信息&lt;br /&gt;
因为我这里服务只需要内部调用，所以这里没有将端口暴露出去&lt;br /&gt;
实际生产环境中，除了需要暴露端口，类似证书，配置文件均可以通过configmap的形式挂载到pod中去&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-deploymentrelease&quot;&gt;apiVersion: v1
kind: Service
metadata:
  name: appnamexx
  namespace: namespacexx
  labels:
    app: appnamexx
spec:
  selector:
    app: appnamexx
  type: NodePort
  ports:
  - name: appnamexx
    port: portxx
    nodePort: nodeportxx
    protocol: TCP
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name:  appnamexx
  namespace: namespacexx
spec:
  minReadySeconds: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  replicas: replicas
  template:
    metadata:
      labels:
        app:  appnamexx
    spec:
      securityContext:
        runAsUser: someuserxx
        fsGroup: somegroupxx
      containers:
      - name: appnamexx
        image: imageaddrxx
        resources:
          limits:
            cpu: 100m
            memory: 1000Mi
          requests:
            cpu: 100m
            memory: 500Mi
        livenessProbe:
          httpGet:
            path: /checkalive
            port: portxx
            scheme: HTTP
          initialDelaySeconds: 60
          timeoutSeconds: 5
        readinessProbe:
          httpGet:
            path: /probe
            port: portxx
            scheme: HTTP
          initialDelaySeconds: 3
          timeoutSeconds: 5
        ports:
        - containerPort: portxx
          name: http
          protocol: TCP
        env:
          - name: SOME_ENVXX
            value: xxx
        volumeMounts:
          - name: configvolumexx
            mountPath: configpathxx
      volumes:
      - name: configvolumexx
        configMap:
          name: app's config

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到生产环境多了很多配置，除了nodeport将应用的端口映射出去，还增加了类似pod内存，cpu资源分配的限制，配置文件的挂载，注意volumes和volumeMounts对应的name要一致，并且这个名字和k8s的configmap的资源名都保持一致。这里才能将congfigmap挂载到对应的pod中去&lt;/p&gt;

&lt;h3 id=&quot;上线调试&quot;&gt;上线&amp;amp;调试&lt;/h3&gt;

&lt;p&gt;上线就是apply对应的资源，最终调试可以参考上一篇讲nginx时讲到的本地调试方式进行本地调试，本地开发环境并不需要打包到镜像并发送到k8s的pod才能调试。只需在nginxcallback到本地的端口即可&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/appink8s/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/appink8s/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Nginx生产实践</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;生产环境nginx，主要接收最前端的流量，然后负载均衡或者引流。记录下目前Nginx常用的一些配置与作用说明，通过这篇文章，可以了解到生产上各种nginx的使用方法与基础技巧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;常用的一些nginx配置&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;测试环境本地项目调试&lt;/li&gt;
  &lt;li&gt;测试环境多端口调试&lt;/li&gt;
  &lt;li&gt;rewrite常用用法&lt;/li&gt;
  &lt;li&gt;root&amp;amp;alias用法与区别&lt;/li&gt;
  &lt;li&gt;生产环境切换&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;测试环境本地项目调试&quot;&gt;测试环境本地项目调试&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-nginx-1&quot;&gt;server {
    listen 80;
    server_name xxx;
    error_page 502 503 504 = @backurl;
    location / {
        proxy_pass http://$remote_addr:8888;
        proxy_set_header Host $http_host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-NginX-Proxy true;
        proxy_set_header X-Real-IP $remote_addr;
    }
    location @backurl {
        proxy_pass http://127.0.0.1:8888;
        proxy_set_header Host $http_host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-NginX-Proxy true;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求工作方法： 访问对应server时，首先找location对应的url,url则指向remote_addr(客户端IP,注意这里的remote_addr需要在nginx设置获取真实ip配置)，当客户端本地未监听8888时，则重新将location指向服务端的8888,即完成测试环境代理本地项目测试需求&lt;/p&gt;

&lt;h3 id=&quot;测试环境多端口调试&quot;&gt;测试环境多端口调试&lt;/h3&gt;
&lt;p&gt;同一服务在测试环境部署N个，那么如何在浏览器指定port请求对应服务？&lt;br /&gt;
通过cookie是一种方法,与测试项目本地调试的配置类似&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-port-nginx&quot;&gt;    location / {
        if ($cookie_port) {
          set $apiport $cookie_port;
        }
        proxy_pass http://$remote_addr:$apiport;
        proxy_set_header Host $http_host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-NginX-Proxy true;
        proxy_set_header X-Real-IP $remote_addr;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实只需要nginx获取到客户端请求时传输的port变量即可，这里将port信息放到cookie中，同样可以放到请求的head中，nginx通过http_x_port来进行反代即可&lt;/p&gt;

&lt;h3 id=&quot;rewrite常用用法&quot;&gt;rewrite常用用法&lt;/h3&gt;

&lt;p&gt;rewrite为了改写请求url,改变浏览器中的请求地址&lt;br /&gt;
有四个标签：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;last      匹配后继续匹配其他规则&lt;/li&gt;
  &lt;li&gt;break     匹配后不匹配其他规则&lt;/li&gt;
  &lt;li&gt;redirect  临时重定向&lt;/li&gt;
  &lt;li&gt;permanent 永久重定向&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用法1：location中直接将url第一个根路径以前的url替换成rewrite指定的url,正则有很多，具体参考nginx-rewrite正则相关的文章&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-rewrite&quot;&gt;  rewrite ^/(.*) http://www.taobao.com/$1 permanent;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法2：例如请求的url是&lt;code class=&quot;highlighter-rouge&quot;&gt;taobao.com/xxx/aa&lt;/code&gt;则rewrite成&lt;code class=&quot;highlighter-rouge&quot;&gt;taobao.com/aa&lt;/code&gt;并执行pass的跳转并且不会继续匹配aa对应的location&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-rewrite2&quot;&gt;location /xxx {
    rewrite ^/xxx(.*) $1 break;
    proxy_pass http://xx.xx.xx.xx:port;
}
location /aa {
    dosomething
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法3：在if判断中,例如如下防盗链配置请求资源。除none blocked域名外其他均rewrite掉&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ifrewrite&quot;&gt;server {
  listen 8080;
  server_name xxx.abc.com
  location ~* ^.+\.(gif|jpg|png|swf|flv|rar|zip)$ {                                   ## location /xx/ {
                                                                                      ##    root /xxx/xx;
    valid_referers none blocked www.xxx.com www.yyy.com *.baidu.com  *.tabobao.com;
    if ($invalid_referer) {
      rewrite ^/ http://www.xxx.com/images/forbidden.png;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rewrite使用方面有很多场景官方文档有详细说明：&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;跳转&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;alias用法与区别&quot;&gt;alias用法与区别&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;root处理结果是将url指向location路径+root路径&lt;/li&gt;
  &lt;li&gt;alias的处理结果是：使用alias路径替换location路径&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;alias目录名后面一定要加”/”，alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用，alias只用于location中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-location-alias&quot;&gt;location ^~ /t/ {
 alias /www/root/xxx/;
}
location = /favicon.ico {
    alias /xxx/favicon.ico;
    break;
}
location /xxx {
    alias /xxx/dist;
    index index.html;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;生产环境切换&quot;&gt;生产环境切换&lt;/h3&gt;

&lt;p&gt;环境切换与端口切换类似，方法可以通过head或者cookie等进行传参，nginx中进行判断，根据不同的变量，进行不同的跳转&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根据来源ip进行跳转&lt;/li&gt;
  &lt;li&gt;根据cookie是否包含version字段进行跳转&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-change&quot;&gt;        location /xxx/ {
            set $xxxpassurl http://xxx-release;
                if ($remote_addr ~ '(xx.xx.xx.x1|xx.xx.xx.x2)' ) {
                        set $xxxpassurl http://xxx-test;
                }
                if ($http_cookie ~ version\=release) {
                        set $xxxpassurl http://xxx-release;
                }
                if ($http_cookie ~ version\=ga) {
                        set $xxxpassurl http://xxx-test;
                }
            rewrite ^/xxx(.*)$  $1 break;
            proxy_pass $xxxpassurl;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $http_connection;
            proxy_http_version 1.1;
        }  
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 14 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/10/nginx/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/10/nginx/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>云主机磁盘分区</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;去年云主机快到期了，对比各个云主机，挑选性价比最高的一家云主机，最后选了ucloud的，因为确实便宜到爆炸啊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;去年这个时候，薅羊毛2c8g的伦敦节点，花了300+一年搞定&lt;br /&gt;
今年看到官网又出了海外节点2折的活动，果断入手&lt;br /&gt;
香港节点2c4g20G+2M带宽，价格550&lt;/p&gt;

&lt;p&gt;以上与本文无关&lt;br /&gt;
发现系统盘有点小，准备扩一下系统盘，20g到40g一年0.01元，呵呵呵，不买我是弟弟啊~&lt;br /&gt;
一顿操作加载系统盘，重装电脑，发现fdisk下面仅仅/dev/vda显示为40g。系统盘已经挂载上去的/dev/vda1对应系统的/目录仍然是20g&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2019-07-01-mkdisk/mkdisk1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有20g没有划入分区？那就分区呗&lt;/p&gt;

&lt;p&gt;fdisk /dev/vda
n p 2 新建分区-建立分区-分区编号（ucloud默认是2-4）
剩下的默认回车就行了，大概意思是选择盘符的起始位置，结束位置，就是划分磁盘的大小
w  最后w保存创建，退出交互模式&lt;/p&gt;

&lt;p&gt;分区建完，格式化磁盘&lt;br /&gt;
mkfs.ext4 /dev/vda2&lt;br /&gt;
如果报错，则在内核将刚创建的分区更新过去&lt;br /&gt;
partprobe&lt;br /&gt;
再格式化&lt;/p&gt;

&lt;p&gt;最后一步，挂载分区&lt;br /&gt;
mkdir /data (创建任意目录)&lt;br /&gt;
mount /dev/vda2 /data&lt;br /&gt;
&lt;img src=&quot;/images/posts/2019-07-01-mkdisk/mkdisk2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Jul 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/07/mkdisk/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/07/mkdisk/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Openshift-生产环境部署</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;生产环境安装openshift&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;主机类型&lt;/th&gt;
      &lt;th&gt;主机名&lt;/th&gt;
      &lt;th&gt;IP地址&lt;/th&gt;
      &lt;th&gt;操作系统&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Master节点&lt;/td&gt;
      &lt;td&gt;master.example.com&lt;/td&gt;
      &lt;td&gt;192.168.172.168&lt;/td&gt;
      &lt;td&gt;Centos 7.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Node节点&lt;/td&gt;
      &lt;td&gt;node1.example.com&lt;/td&gt;
      &lt;td&gt;192.168.172.169&lt;/td&gt;
      &lt;td&gt;Centos 7.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Node节点&lt;/td&gt;
      &lt;td&gt;node2.example.com&lt;/td&gt;
      &lt;td&gt;192.168.172.170&lt;/td&gt;
      &lt;td&gt;Centos 7.2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;1配置主机名&quot;&gt;1.配置主机名&lt;/h2&gt;

&lt;p&gt;hostnamectl set-hostname master.example.com&lt;br /&gt;
配置相关域名解析，使主机名可解析到对应ip地址&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-host&quot;&gt;192.168.172.168  master.example.com  
192.168.172.169  node1.example.com  
192.168.172.170  node2.example.com  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有节点设置网络&lt;br /&gt;
查看网络链接&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;nmcli con show&lt;/code&gt;
打开链接&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;nmcli con up eth0&lt;/code&gt;&lt;br /&gt;
设置开机自启动&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;nmcli con mod eth0 connection.autoconnect yes&lt;/code&gt;&lt;br /&gt;
重启网络服务&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl restart NetworkManager&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;2安装及配置软件包&quot;&gt;2.安装及配置软件包&lt;/h2&gt;

&lt;p&gt;所有节点安装openshift依赖软件包&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;yum install -y wget git net-tools bind-utils iptables-services bridge-utils bash-completion&lt;/code&gt;&lt;br /&gt;
所有节点安装容器引擎docker&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;yum install -y docker&lt;/code&gt;&lt;br /&gt;
修改配置存储&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;vim /etc/sysconfig/docker-storage-setup&lt;/code&gt;&lt;br /&gt;
添加 ENVS=/dev/sdb
执行docker-storage-setup&lt;/p&gt;

&lt;p&gt;在Master节点启动EPEL安装ansible&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-8.noarch.rpm  
&lt;span class=&quot;nb&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;s/^enabled=1/enabled=0/&quot;&lt;/span&gt; /etc/yum.repos.d/epel.repo  
yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--enablerepo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;epel &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;ansible pyopenSSL  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Master节点生成SSH密钥&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-keygen -f /root/.ssh/id_rsa -N ''&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ansible基于Agentless架构实现，不需要在目标主机安装agent依赖ssh远程控制协议，所以需要配置master和node节点互信&lt;br /&gt;
在Master节点执行：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;host &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;master.example.com &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
node1.example.com &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
node2.example.com&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;ssh-copy-id &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; ~/.ssh/id_rsa.pub &lt;span class=&quot;nv&quot;&gt;$host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Master节点安装Openshift的ansible Playbook&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://github.com/openshift/openshift-ansible/archive/openshift-ansible-3.3.26-1.tar.gz  
&lt;span class=&quot;nb&quot;&gt;tar &lt;/span&gt;zxf openshift-ansible-3.3.26-1.tar.gz  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装单master可以不单独安装etcd,这里选择安装单节点的etcd,生产环境安装3节点的etcd集群,确保高可用&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; etcd  
systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;etcd  
systemctl start etcd  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;配置ansible&quot;&gt;配置ansible&lt;/h2&gt;

&lt;p&gt;备份原有ansible的host&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;cp /etc/ansible/hosts /etc/ansible/hosts-bk&lt;/code&gt;&lt;br /&gt;
修改hosts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-hosts文件&quot;&gt;[OSEv3:children]
masters
nodes
etcd

[OSEv3:vars]
ansible_ssh_user=root
openshift_deployment_type=origin
openshift_release=1.3.0

openshift_master_identity_providers=[{'name': 'htpasswd_auth', 'login': 'true', 'challenge': 'true', 'kind': 'HTPasswdPasswordIdentityProvider', 'filename': '/etc/origin/master/htpasswd'}]

[masters]
openshift-test-master

[nodes]
master.example.com  
node1.example.com  
node2.example.com

[etcd]
openshift-test-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行安装&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ansible-playbook ~/openshift-ansible-3.3.26-1/playbooks/byo/config.yml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;执行完成以后，通过oc get node 查看节点状态&lt;/p&gt;

&lt;p&gt;基础安装完毕以后，进行组件和功能的配置&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对接用户身份信息库&lt;/li&gt;
  &lt;li&gt;导入Image Stream&lt;/li&gt;
  &lt;li&gt;导入Template&lt;/li&gt;
  &lt;li&gt;部署Router&lt;/li&gt;
  &lt;li&gt;部署Registry&lt;/li&gt;
  &lt;li&gt;部署度量收集组件&lt;/li&gt;
  &lt;li&gt;部署日志聚合组件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用户身份信息库：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;openshift_master_identity_providers=[{'name': 'htpasswd_auth', 'login': 'true', 'challenge': 'true', 'kind': 'HTPasswdPasswordIdentityProvider', 'filename': '/etc/origin/master/htpasswd'}]&lt;/code&gt;&lt;br /&gt;
定义了文件/etc/origin/master/htpasswd作为用户身份信息库，我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;htpasswd -b /etc/origin/master/htpasswd dev dev&lt;/code&gt;来创建用户&lt;/p&gt;

&lt;p&gt;is和template用ansible部署时默认已经部署上了&lt;/p&gt;

&lt;p&gt;Router部署&lt;br /&gt;
Router是以容器的形式运行在Openshift平台，默认情况不知道容器运行在哪个node上&lt;br /&gt;
为node打上标签(Label),然后通过节点选择器(NodeSelector)指定容器运行的node&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc label node node1.example.com infra=yes&lt;/code&gt;&lt;br /&gt;
查看node节点&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc get node --show-labels&lt;/code&gt;&lt;br /&gt;
为Router使用的Service Account赋权&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;oadm policy add-scc-to-user privileged system:serviceaccount:default:router
oadm policy add-cluster-role-to-user cluster-reader system:serviceaccount:default:router
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;部署router&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oadm router ose-router --replicas=1 --service-account=router --selector='infra=yes'&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Registry部署&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oadm registry --config='/etc/origin/master/admin.kubeconfig' --service-account=registry --selector='infra=yes' -n default&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看pod&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc get pod -n default|grep registry&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/openshift2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/openshift2/</guid>
        
        <category>Openshift</category>
        
        
      </item>
    
      <item>
        <title>Openshift-测试环境AllInOne</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;记录Openshift笔记，刚准备熟悉一下mysql，boss要求看openshift相关的东西，所以mysql系列的后续再更新，边写openshift边学习沉淀吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;安装openshift-all-in-one&quot;&gt;安装openshift-All in one&lt;/h2&gt;

&lt;p&gt;https://www.clouda.ca/blog/general/openshift-on-centos-7-quick-installation/&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;wget https://github.com/openshift/origin/releases/download/v1.3.0/openshift-origin-server-v1.3.0-3ab7af3d097b57f933eccef684a714f2368804e7-linux-64bit.tar.gz&quot;&gt;二进制下载地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;oc命令行创建应用&quot;&gt;oc命令行创建应用&lt;/h3&gt;

&lt;p&gt;因为oc命令带有权限管控，所以在使用oc命令前，需要通过oc login 登录&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc login -u test https://10.50.64.34:8443&lt;/code&gt;&lt;br /&gt;
创建项目(这个项目类似在k8s创建一个namespace)&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc new-project hello-world-oc&lt;/code&gt;&lt;br /&gt;
部署应用&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc new-app openshift/hello-openshift&lt;/code&gt;&lt;br /&gt;
查看pod&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc get pod&lt;/code&gt;&lt;br /&gt;
查看pod详细信息&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc describe pod hello-openshift-1-z8mki&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;集群管理员账号登录&quot;&gt;集群管理员账号登录&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir -p ~/.kube
cp /opt/openshift/openshift.local.config/master/admin.kubeconfig ~/.kube/config
登录  
oc login -u system:admin
查看集群节点  
oc get node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加route&quot;&gt;添加route&lt;/h3&gt;

&lt;p&gt;类似kube-proxy,是外界访问openshift的入口，外部请求都会到达router&lt;br /&gt;
切换到default项目&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oc project default&lt;/code&gt;
router组件需要读取集群的信息，它关联一个系统账号service account并为这个账号赋权。&lt;br /&gt;
(这个账号是专门供程序和组件使用的账号)&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;oadm policy add-scc-to-user privileged system:serviceaccount:default:router&lt;/code&gt;
创建router实例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;oadm router router --replicas=1 --service-account=router
oc get pod -n default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加registry&quot;&gt;添加registry&lt;/h3&gt;
&lt;p&gt;集群的docker registry内部docker镜像仓库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;oc project default
oadm registry --config=/opt/openshift/openshift.local.config/master/admin.kubeconfig --service-account=registry
oc get pod  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为registry没有启用https,所以需要修改docker配置，让docker以非https模式连接到registry.&lt;br /&gt;
在OPTIONS变量值中添加参数’–insecure-registry=172.30.0.0/16’&lt;br /&gt;
重启docker systemctl restart docker&lt;/p&gt;

&lt;h3 id=&quot;添加image-stream&quot;&gt;添加Image Stream&lt;/h3&gt;

&lt;p&gt;is镜像集合，openshift并不一定要用到is，is是为了更加方便的将镜像管理和使用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;oc project openshift
openshift version
curl https://raw.githubusercontent.com/openshift/origin/v1.3.0/examples/image-streams/image-streams-centos7.json|oc create -f - -n openshift
oc get is -n openshift
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加template&quot;&gt;添加Template&lt;/h3&gt;

&lt;p&gt;openshift定义了一些template供用户使用，模板定义一个多个部署镜像的集合，定义部署依赖对象以及配置参数项&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;oc project openshift
oc create -f https://raw.githubusercontent.com/openshift/origin/v1.3.0/examples/quickstarts/cakephp-mysql.json -n openshift  
oc get template -n openshift
oc get template cakephp-mysql-example -o json -n openshift
oc create -f https://raw.githubusercontent.com/nichochen/openshift-book-source/master/template/wildfly-basic-s2i.template.json -n openshift  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 20 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/openshift1/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/openshift1/</guid>
        
        <category>Openshift</category>
        
        
      </item>
    
      <item>
        <title>Mysql最佳实践</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;记录mysql读书日记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;安装mysql&quot;&gt;安装mysql&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ curl -LO http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm&lt;/code&gt;
安装 mysql 源&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo yum localinstall mysql57-community-release-el7-11.noarch.rpm&lt;/code&gt;
检查 yum 源是否安装成功&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-a&quot;&gt;
$ sudo yum repolist enabled | grep &quot;mysql.*-community.*&quot;
mysql-connectors-community           MySQL Connectors Community              21
mysql-tools-community                MySQL Tools Community                   38
mysql57-community                    MySQL 5.7 Community Server             130
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上所示，找到了 mysql 的安装包&lt;/p&gt;

&lt;p&gt;2.安装&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo yum install mysql-community-server&lt;/code&gt;
3.启动&lt;/p&gt;

&lt;p&gt;安装服务&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo systemctl enable mysqld&lt;/code&gt;
启动服务&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo systemctl start mysqld&lt;/code&gt;
查看服务状态&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo systemctl status mysqld&lt;/code&gt;
4.修改 root 默认密码&lt;/p&gt;

&lt;p&gt;MySQL 5.7 启动后，在 /var/log/mysqld.log 文件中给 root 生成了一个默认密码。通过下面的方式找到 root 默认密码，然后登录 mysql 进行修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-b&quot;&gt;$ grep 'temporary password' /var/log/mysqld.log
[Note] A temporary password is generated for root@localhost: **********
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登录 MySQL 并修改密码&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Enter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;USER&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'@'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localhost&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDENTIFIED&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyNewPass4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;注意：&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MySQL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;默认安装了密码安全检查插件（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;validate_password&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;位。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过 MySQL 环境变量可以查看密码策略的相关信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-e&quot;&gt;
mysql&amp;gt; SHOW VARIABLES LIKE 'validate_password%';
+--------------------------------------+--------+
| Variable_name                        | Value  |
+--------------------------------------+--------+
| validate_password_check_user_name    | OFF    |
| validate_password_dictionary_file    |        |
| validate_password_length             | 8      |
| validate_password_mixed_case_count   | 1      |
| validate_password_number_count       | 1      |
| validate_password_policy             | MEDIUM |
| validate_password_special_char_count | 1      |
+--------------------------------------+--------+
7 rows in set (0.01 sec)
具体修改，参见 http://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定密码校验策略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-f&quot;&gt;$ sudo vi /etc/my.cnf

[mysqld]
# 添加如下键值对, 0=LOW, 1=MEDIUM, 2=STRONG
validate_password_policy=0
禁用密码策略

$ sudo vi /etc/my.cnf
	
[mysqld]
# 禁用密码校验策略
validate_password = off
重启 MySQL 服务，使配置生效

$ sudo systemctl restart mysqld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.添加远程登录用户&lt;/p&gt;

&lt;p&gt;MySQL 默认只允许 root 帐户在本地登录，如果要在其它机器上连接 MySQL，必须修改 root 允许远程连接，或者添加一个允许远程连接的帐户，为了安全起见，本例添加一个新的帐户：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&amp;gt; GRANT ALL PRIVILEGES ON *.* TO 'admin'@'%' IDENTIFIED BY 'secret' WITH GRANT OPTION;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;6.配置默认编码为 utf8&lt;/p&gt;

&lt;p&gt;MySQL 默认为 latin1, 一般修改为 UTF-8&lt;/p&gt;

&lt;p&gt;$ vi /etc/my.cnf
[mysqld]&lt;/p&gt;
&lt;h1 id=&quot;在myslqd下添加如下键值对&quot;&gt;在myslqd下添加如下键值对&lt;/h1&gt;
&lt;p&gt;character_set_server=utf8
init_connect=’SET NAMES utf8’
重启 MySQL 服务，使配置生效&lt;/p&gt;

&lt;p&gt;$ sudo systemctl restart mysqld
查看字符集&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; SHOW VARIABLES LIKE ‘character%’;
+————————–+—————————-+
| Variable_name            | Value                      |
+————————–+—————————-+
| character_set_client     | utf8                       |
| character_set_connection | utf8                       |
| character_set_database   | utf8                       |
| character_set_filesystem | binary                     |
| character_set_results    | utf8                       |
| character_set_server     | utf8                       |
| character_set_system     | utf8                       |
| character_sets_dir       | /usr/share/mysql/charsets/ |
+————————–+—————————-+
8 rows in set (0.00 sec
7.开启端口&lt;/p&gt;

&lt;p&gt;$ sudo firewall-cmd –zone=public –add-port=3306/tcp –permanent
$ sudo firewall-cmd –reload&lt;/p&gt;

&lt;p&gt;简易方式快速启动：
宿主机
curl -LO http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm
yum install mysql-community-client -y&lt;/p&gt;

&lt;p&gt;yum install  docker docker-compose -y&lt;/p&gt;

&lt;p&gt;mkdir -p /mysql
mkdir -p /mysql/data
mkdir -p /mysql/config&lt;/p&gt;

&lt;p&gt;将my.conf复制到/mysql/config下
将docker-compose.yml拷贝到/mysql下&lt;/p&gt;

&lt;p&gt;my.cnf配置如下（.cnf结尾）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-my.cnf&quot;&gt;# The MySQL database server configuration file.
#
# You can copy this to one of:
# - &quot;/etc/mysql/my.cnf&quot; to set global options,
# - &quot;~/.my.cnf&quot; to set user-specific options.
#
# One can use all long options that the program supports.
# Run program with --help to get a list of available options and with
# --print-defaults to see which it would actually understand and use.
#
# For explanations see
# http://dev.mysql.com/doc/mysql/en/server-system-variables.html

# This will be passed to all mysql clients
# It has been reported that passwords should be enclosed with ticks/quotes
# escpecially if they contain &quot;#&quot; chars...
# Remember to edit /etc/mysql/debian.cnf when changing the socket location.

# Here is entries for some specific programs
# The following values assume you have at least 32M ram

[mysqld_safe]
socket		= /var/run/mysqld/mysqld.sock
nice		= 0

[mysqld]
#
# * Basic Settings
#
user		= mysql
pid-file	= /var/run/mysqld/mysqld.pid
socket		= /var/run/mysqld/mysqld.sock
port		= 3306
basedir		= /usr
datadir		= /var/lib/mysql
tmpdir		= /tmp
lc-messages-dir	= /usr/share/mysql
skip-external-locking
skip-grant-tables
#
# Instead of skip-networking the default is now to listen only on
# localhost which is more compatible and is not less secure.
bind-address		= 0.0.0.0
#
# * Fine Tuning
#
key_buffer_size		= 16M
max_allowed_packet	= 16M
thread_stack		= 192K
thread_cache_size       = 8
# This replaces the startup script and checks MyISAM tables if needed
# the first time they are touched
myisam-recover-options  = BACKUP
#max_connections        = 100
#table_cache            = 64
#thread_concurrency     = 10
#
# * Query Cache Configuration
#
query_cache_limit	= 1M
query_cache_size        = 16M
#
# * Logging and Replication
#
# Both location gets rotated by the cronjob.
# Be aware that this log type is a performance killer.
# As of 5.1 you can enable the log at runtime!
#general_log_file        = /var/log/mysql/mysql.log
#general_log             = 1
#
# Error log - should be very few entries.
#
log_error = /var/log/mysql/error.log
#
# Here you can see queries with especially long duration
#log_slow_queries	= /var/log/mysql/mysql-slow.log
#long_query_time = 2
#log-queries-not-using-indexes
#
# The following can be used as easy to replay backup logs or for replication.
# note: if you are setting up a replication slave, see README.Debian about
#       other settings you may need to change.
#server-id		= 1
#log_bin			= /var/log/mysql/mysql-bin.log
expire_logs_days	= 10
max_binlog_size   = 100M
#binlog_do_db		= include_database_name
#binlog_ignore_db	= include_database_name
#
# * InnoDB
#
# InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.
# Read the manual for more InnoDB related options. There are many!
#
# * Security Features
#
# Read the manual, too, if you want chroot!
# chroot = /var/lib/mysql/
#
# For generating SSL certificates I recommend the OpenSSL GUI &quot;tinyca&quot;.
#
# ssl-ca=/etc/mysql/cacert.pem
# ssl-cert=/etc/mysql/server-cert.pem
# ssl-key=/etc/mysql/server-key.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker-compose文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-compose&quot;&gt;version: '3'
services:
  mysql:
    image: mysql:5.7
    container_name: mysql
    command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci #设置utf8字符集
    restart: always
    ports:
      - 6606:3306
    volumes:
      - &quot;/mysql/data:/var/lib/mysql&quot;
      - &quot;/mysql/config:/etc/mysql/conf.d&quot;
    environment:
      MYSQL_ROOT_PASSWORD: &quot;123456&quot;   #root管理员用户密码
      MYSQL_USER: test   #创建test用户
      MYSQL_PASSWORD: test  #设置test用户的密码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker-compose up -d 启动&lt;br /&gt;
宿主机登录mysql: mysql -uroot -P6606 -p -h127.0.0.1&lt;/p&gt;

&lt;p&gt;报错&lt;code class=&quot;highlighter-rouge&quot;&gt;Access denied for user 'root'@'localhost' (using password: YES)&lt;/code&gt;
配置文件添加：skip-grant-tables
进入数据量，更新密码update mysql.user set authentication_string=password(‘&lt;strong&gt;**&lt;/strong&gt;&lt;em&gt;’) where user=’&lt;/em&gt;&lt;strong&gt;**&lt;/strong&gt;’&lt;/p&gt;

</description>
        <pubDate>Mon, 14 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/learnmysql/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/learnmysql/</guid>
        
        <category>Mysql</category>
        
        
      </item>
    
      <item>
        <title>Linux常用快捷键【持续更新...】</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;一些好用的命令每次要用的时候，不记得怎么用，用起来时区网上查找。死循环，决定整理一份自己常用且好用的一些整理，梳理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;vim快捷键&quot;&gt;Vim快捷键&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;文档操作&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:e!&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;重新加载当前文档，并丢弃已做的改动&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:f newname&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;相当于复制一个文件到新名字&lt;/td&gt;
      &lt;td&gt;保存退出则相当于创建一个新的文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;光标屏幕移动&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;k/j/h/l&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上下左右&lt;/td&gt;
      &lt;td&gt;作用和方向键左右一致&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SHIFT+e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;光标移动下一个字符串的结尾&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SHIFT+h/m/l&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;光标移动当前窗口的首，中，尾&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zz&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;屏幕当前行至于屏幕中间&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL+y/e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;屏幕上下滚动&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SHIFT+e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;屏幕移动下一个字符串的结尾&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;编辑操作&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;u&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;撤销&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;光标向后删除&lt;/td&gt;
      &lt;td&gt;光标向前：X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yn&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;当前光标向下复制n行&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;光标向后删除字符&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;向前删除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;重复前一个动作&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:vs xx/xx/file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;垂直分屏打开文件file&lt;/td&gt;
      &lt;td&gt;切换屏幕ctrl+w+w这个切换屏幕同样适用vimdiff&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:sp xx/xx/file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;水平分屏打开文件file&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:!command&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;暂时离开vi，到命令行下执行命令&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;编程相关&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ci&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;修改”内的内容&lt;/td&gt;
      &lt;td&gt;相当于di”+i,实用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;多行操作&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;ctrl+v选择编辑的列，shift+i编辑，esc&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;linux常用快捷键&quot;&gt;Linux常用快捷键&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;常用命令&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;–命令行快捷键–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+k&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;剪切(删除)光标到行尾的字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+u&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;剪切(删除)光标到行首的字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+w&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;剪切(删除)光标前一个单词&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+y&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;粘贴k,u,w的字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esc+b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动光标到当前单词的开头&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esc+f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动光标到当前单词的结尾&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–ls&amp;amp;ll–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;按时间排序，最新在最前面&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -rt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;按时间倒序排序，最新在最后面&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–去重–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uniq&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;文件去重行或用&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;传替，注意是按行去重&lt;/td&gt;
      &lt;td&gt;eg: &lt;code class=&quot;highlighter-rouge&quot;&gt;cat file|sort|uniq -c&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;linux-一些命令&quot;&gt;Linux 一些命令&lt;/h3&gt;

&lt;p&gt;变量=a,文件=file&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Command&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;–文件处理–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sed -i '/^$/d' file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;清除文件所有空白的行&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sed -i '/#/d'  file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;清除文件中所有包含某字符的行，以#为例&lt;/td&gt;
      &lt;td&gt;//中间支持正则,比如删除以#开头则^#&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–字符处理–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if [[ $a =~ ':' ]]&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;判断字符串中是否包含某字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a#*.}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中第一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其左边的字符&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=2.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a##*.}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中最后一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其左边的字符&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a%.*}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中最后一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其右边的字符串&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=1.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a%%.*}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其右边的字符串&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:0:$}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;取字符串第一到最后一个字符&lt;/td&gt;
      &lt;td&gt;eg: ${a:1:2} a=1234 -&amp;gt; a=23&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a/b/c}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将a字符串中的第一个b字符替换成c字符&lt;/td&gt;
      &lt;td&gt;eg: ${a/2/3} a=1232 -&amp;gt; a=1332&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a//b/c}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将a字符串中的所有b字符替换成c字符&lt;/td&gt;
      &lt;td&gt;eg: ${a/2/3} a=1232 -&amp;gt; a=1333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${#a}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;返回一个整数值，数值为字符串长度&lt;/td&gt;
      &lt;td&gt;eg: a=123 echo ${#a} -&amp;gt; 3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a-b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:-b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值或空，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a+b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a空或非空，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:+b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a非空，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a=b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值，则使用b为返回值,并赋值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:=b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值或空，则使用b为返回值，并赋值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Thu, 27 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/useful/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/useful/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Redis集群下生产实践</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;背景：近期弄了一套集群环境的服务，其中包含mongo数据库集群，redis集群和其他的服务集群，高可用的架构，为了支持真正意义的高可用，而做了这篇博客&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;集群高可用&quot;&gt;集群高可用&lt;/h3&gt;

&lt;p&gt;以6节点三主三从为例&lt;br /&gt;
cluster-enabled指定启动集群模式&lt;br /&gt;
cluster-config-file指定保存节点配置的文件，redis集群启动后会自动创建修改维护这些nodes.conf文件&lt;/p&gt;

&lt;p&gt;集群模式的最简节点配置文件如下&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;port 7000
cluster-enabled &lt;span class=&quot;nb&quot;&gt;yes
&lt;/span&gt;cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly &lt;span class=&quot;nb&quot;&gt;yes&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以添加一些配置指定数据文件，日志等&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pidfile /var/run/redis/redis.pid
&lt;span class=&quot;nb&quot;&gt;bind &lt;/span&gt;127.0.0.1 xxx.xxx.xxx.xxx
loglevel notice
logfile /xxx/log/redis/redis.log
&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt; /xxx/db/redis/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外还有一些配置，例如负载很大的服务修改&lt;strong&gt;tcp-backlog、tcp-keepalive&lt;/strong&gt;参数等&lt;/p&gt;

&lt;p&gt;按上面方法，通过修改监听端口启动的不同节点的redis实例，但还不是集群&lt;br /&gt;
&lt;strong&gt;redis-trib 位于Redis源码的src文件夹中,它是一个Ruby程序&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./redis-trib.rb create &lt;span class=&quot;nt&quot;&gt;--replicas&lt;/span&gt; 1  ip1:port1 ip2:port2 ip3:port3 ip4:port4 ip5:port5 ip6:port6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;replicas 1&lt;/code&gt;这个参数指定在6个节点中为每个主节点创建一个从节点，则执行完后会生成对应的三主三从节点配置。&lt;/p&gt;

&lt;h3 id=&quot;哨兵高可用&quot;&gt;哨兵高可用&lt;/h3&gt;

&lt;p&gt;以一主两从三节点介绍&lt;br /&gt;
redis节点的默认配置文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis-default.conf&quot;&gt;daemonize yes
pidfile /var/run/redis/redis.pid
port 6379
tcp-backlog 2048
bind 127.0.0.1 xxx.xxx.xxx.xxx
timeout 0
tcp-keepalive 60
loglevel notice
logfile /xxx/xxx/redis.log
databases 16
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir /xxx/xxx/redis/
slave-serve-stale-data yes
slave-read-only yes
repl-disable-tcp-nodelay no
slave-priority 100
appendonly no
appendfilename &quot;appendonly.aof&quot;
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
lua-time-limit 5000
slowlog-log-slower-than 10000
slowlog-max-len 128
latency-monitor-threshold 0
notify-keyspace-events &quot;&quot;
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-entries 512
list-max-ziplist-value 64
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果加密的话&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis加密&quot;&gt;requirepass  xxxxx  　　#设置redis登录密码
masterauth   xxxxx　　  #主从认证密码，否则主从不能同步
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一主两从，主节点使用上面默认配置启动&lt;br /&gt;
从节点在主节点配置基础上增加一条&lt;code class=&quot;highlighter-rouge&quot;&gt;slaveof 127.0.0.1 6380&lt;/code&gt;  其中ip和端口写主节点的ip和端口&lt;br /&gt;
entinel 哨兵(执行文件和redis-server同目录下)&lt;br /&gt;
每个节点创建一个sentinel.conf文件，在默认的配置上只需修改port,其他的配置三个节点保持一致&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sentinel-default.conf&quot;&gt;port 26379
dir /tmp  
sentinel monitor mymaster 192.168.248.131 6379 2  
sentinel down-after-milliseconds mymaster 30000  
sentinel parallel-syncs mymaster 1  
sentinel failover-timeout mymaster 180000  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果redis需要密码的话加上auth-pass&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis加密&quot;&gt;sentinel auth-pass mymaster xxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动redis主从和哨兵
&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-server redis.conf &amp;amp;&lt;/code&gt;(如果不在一个文件夹下注意路径)&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-sentinel sentinel.conf &amp;amp;&lt;/code&gt;启动sentinel&lt;/p&gt;

&lt;h3 id=&quot;集群高可用和哨兵高可用对比&quot;&gt;集群高可用和哨兵高可用对比&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;单节点&lt;/th&gt;
      &lt;th&gt;集群模式&lt;/th&gt;
      &lt;th&gt;哨兵模式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;运作模式&lt;/td&gt;
      &lt;td&gt;单节点，宕机则停止服务&lt;/td&gt;
      &lt;td&gt;无中心节点，多节点服务&lt;/td&gt;
      &lt;td&gt;由哨兵处理故障转移存在性能瓶颈&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;分片&lt;/td&gt;
      &lt;td&gt;单实例&lt;/td&gt;
      &lt;td&gt;按槽分配，每个节点分配不同的槽，控制每个节点的请求和数据量&lt;/td&gt;
      &lt;td&gt;每个主分担1/N&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可用性&lt;/td&gt;
      &lt;td&gt;无容错性&lt;/td&gt;
      &lt;td&gt;集群节点内置了高可用和复制性能&lt;/td&gt;
      &lt;td&gt;配置sentinel实现复制和高可用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;

&lt;p&gt;还存在一个问题，如果程序中写死了写缓存的地址，但是当masterdown掉之后新的master的地址可能是发生变化的，所以此时我们需要keepalived来实现地址的漂移。&lt;br /&gt;
看到过一遍关于这个方法的解决方案是基于sentinel的keepalived&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/huangyimo/article/details/76618532&quot;&gt;哨兵+keepalived，请参考&lt;/a&gt;&lt;br /&gt;
参考方法中也提到了局限性，包括不受控网络以及云主机环境，无法提供虚拟ip等情况&lt;/p&gt;

&lt;p&gt;这里可通过脚本的方法解决程序缓存地址的问题,能解决没有虚拟ip以及不可控网络的方法&lt;br /&gt;
同样，这个方法无论是集群模式的redis和哨兵模式的redis,都适用&lt;br /&gt;
脚本填入redis节点的ip，并在本地的hosts写入redis解析地址(如果是多master节点，可以改写一下脚本)&lt;br /&gt;
脚本每2秒检测一次当前集群的master，如果master连接不上或者变了，那么脚本会直接替换掉解析中的ip&lt;br /&gt;
程序如果还不能正常，脚本还可以加入重启服务的部分。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#要求1: /etc/hosts里面写入 &quot;1.1.1.1 redis-tb&quot; 的解析规则&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#要求2: 该脚本要有读写/etc/hosts的权限，建议用root&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;hostlist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'1.1.1.1'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2.2.2.2'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'3.3.3.3'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;
checkismaster&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;3 &lt;span class=&quot;nv&quot;&gt;ismaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;info |timeout 2 redis-cli &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'role'&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;':'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{print $2}'&lt;/span&gt;|grep &lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;master&quot;&lt;/span&gt;|wc &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ismaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ismaster&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;then
     &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;nowhost is master&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else
   &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;nowhost not master&quot;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1
  &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do
  &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;nowhost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/hosts | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'redis-tb'&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{print $1}'&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
  checkismaster &lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$flag&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;i &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;hostlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[@]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;do
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;now is finding master in hostlist&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;checking ip --  &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;3 &lt;span class=&quot;nv&quot;&gt;checkmaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;info |timeout 2 redis-cli &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'role'&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;':'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{print $2}'&lt;/span&gt;|grep &lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;master&quot;&lt;/span&gt;|wc &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;checkmaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;when checkip is master, then checkmaster=1 ---  &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$checkmaster&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$checkmaster&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;then
     &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;now changeing nowhost to master = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; to &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
     &lt;span class=&quot;nb&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'s/'&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/g'&lt;/span&gt; /etc/hosts
    &lt;span class=&quot;k&quot;&gt;fi
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
   &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;sleep &lt;/span&gt;2
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nohup sh xx.sh &amp;amp;&lt;br /&gt;
将脚本放后台执行，这个脚本会将三个节点的主写到hosts中，并且每两秒检测一次，在应用中写上hosts指定的master地址&lt;/p&gt;

&lt;h3 id=&quot;附件1redis配置详解&quot;&gt;附件1：redis配置详解&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis配置详解&quot;&gt;# Redis configuration file example.
# ./redis-server /path/to/redis.conf

################################## INCLUDES ###################################
#这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。
# include /path/to/local.conf
# include /path/to/other.conf

################################ GENERAL #####################################

#是否在后台执行，yes：后台运行；no：不是后台运行（老版本默认）
daemonize yes

  #3.2里的参数，是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码   和bind，可以开启。否   则最好关闭，设置为no。
  protected-mode yes
#redis的进程文件
pidfile /var/run/redis/redis-server.pid

#redis监听的端口号。
port 6379

#此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的/proc/sys/net/core/somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。在/etc/sysctl.conf中添加:net.core.somaxconn = 2048，然后在终端中执行sysctl -p。
tcp-backlog 511

#指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求
bind 127.0.0.1

#配置unix socket来让redis支持监听本地连接。
# unixsocket /var/run/redis/redis.sock
#配置unix socket使用文件的权限
# unixsocketperm 700

# 此参数为设置客户端空闲超过timeout，服务端会断开连接，为0则服务端不会主动断开连接，不能小于0。
timeout 0

#tcp keepalive参数。如果设置不为0，就使用配置tcp的SO_KEEPALIVE值，使用keepalive有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在Linux内核中，设置了keepalive，redis会定时给对端发送ack。检测到对端关闭需要两倍的设置值。
tcp-keepalive 0

#指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的信息，但是没有debug级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息）
loglevel notice

#指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的redis标准输出是/dev/null。
logfile /var/log/redis/redis-server.log

#是否打开记录syslog功能
# syslog-enabled no

#syslog的标识符。
# syslog-ident redis

#日志的来源、设备
# syslog-facility local0

#数据库的数量，默认使用的数据库是DB 0。可以通过”SELECT “命令选择一个db
databases 16

################################ SNAPSHOTTING ################################
# 快照配置
# 注释掉“save”这一行配置项就可以让保存数据库功能失效
# 设置sedis进行数据库镜像的频率。
# 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） 
# 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） 
# 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）
save 900 1
save 300 10
save 60 10000

#当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误
stop-writes-on-bgsave-error yes

#使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间
rdbcompression yes

#是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。
rdbchecksum yes

#rdb文件的名称
dbfilename dump.rdb

#数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录
dir /var/lib/redis

################################# REPLICATION #################################
#复制选项，slave复制对应的master。
# slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;

#如果master设置了requirepass，那么slave要连上master，需要有master的密码才行。masterauth就是用来配置master的密码，这样可以在连上master后进行认证。
# masterauth &amp;lt;master-password&amp;gt;

#当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data设置为no，除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master in progress”。
slave-serve-stale-data yes

#作为从服务器，默认情况下是只读的（yes），可以修改成NO，用于写（不建议）。
slave-read-only yes

#是否使用socket方式复制数据。目前redis复制提供两种方式，disk和socket。如果新的slave连上来或者重连的slave无法部分同步，就会执行全量同步，master会生成rdb文件。有2种方式：disk方式是master创建一个新的进程把rdb文件保存到磁盘，再把磁盘上的rdb文件传递给slave。socket是master创建一个新的进程，直接把rdb文件以socket的方式发给slave。disk方式的时候，当一个rdb保存的过程中，多个slave都能共享这个rdb文件。socket的方式就的一个个slave顺序复制。在磁盘速度缓慢，网速快的情况下推荐用socket方式。
repl-diskless-sync no

#diskless复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。所以最好等待一段时间，等更多的slave连上来。
repl-diskless-sync-delay 5

#slave根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。
# repl-ping-slave-period 10

#复制连接超时时间。master和slave都有超时时间的设置。master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。需要注意的是repl-timeout需要设置一个比repl-ping-slave-period更大的值，不然会经常检测到超时。
# repl-timeout 60

#是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。
repl-disable-tcp-nodelay no

#复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有slave的一段时间，内存会被释放出来，默认1m。
# repl-backlog-size 5mb

#master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。
# repl-backlog-ttl 3600

#当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。而配置成0，永远不会被选举。
slave-priority 100

#redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。
# min-slaves-to-write 3

#延迟小于min-slaves-max-lag秒的slave才认为是健康的slave。
# min-slaves-max-lag 10

# 设置1或另一个设置为0禁用这个特性。
# Setting one or the other to 0 disables the feature.
# By default min-slaves-to-write is set to 0 (feature disabled) and
# min-slaves-max-lag is set to 10.

################################## SECURITY ###################################
#requirepass配置可以让用户使用AUTH命令来认证密码，才能使用其他命令。这让redis可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证。使用requirepass的时候需要注意，因为redis太快了，每秒可以认证15w次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码。
# requirepass foobared

#把危险的命令给修改成其他名称。比如CONFIG命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用。
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52

#设置成一个空的值，可以禁止一个命令
# rename-command CONFIG &quot;&quot;
################################### LIMITS ####################################

# 设置能连上redis的最大客户端连接数量。默认是10000个客户端连接。由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32。如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接。
# maxclients 10000

#redis配置的最大内存容量。当内存满了，需要配合maxmemory-policy策略进行处理。注意slave的输出缓冲区是不计算在maxmemory内的。所以为了防止主机内存使用完，建议设置的maxmemory需要更小一些。
# maxmemory &amp;lt;bytes&amp;gt;

#内存容量超过maxmemory后的处理策略。
#volatile-lru：利用LRU算法移除设置过过期时间的key。
#volatile-random：随机移除设置过过期时间的key。
#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）
#allkeys-lru：利用LRU算法移除任何key。
#allkeys-random：随机移除任何key。
#noeviction：不移除任何key，只是返回一个写错误。
#上面的这些驱逐策略，如果redis没有合适的key驱逐，对于写命令，还是会返回错误。redis将不再接收写请求，只接收get请求。写命令包括：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sort。
# maxmemory-policy noeviction

#lru检测的样本数。使用lru或者ttl淘汰算法，从需要淘汰的列表中随机选择sample个key，选出闲置时间最长的key移除。
# maxmemory-samples 5

############################## APPEND ONLY MODE ###############################
#默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。
appendonly no

#aof文件名
appendfilename &quot;appendonly.aof&quot;

#aof持久化策略的配置
#no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。
#always表示每次写入都执行fsync，以保证数据同步到磁盘。
#everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。
appendfsync everysec

# 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。
no-appendfsync-on-rewrite no

#aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。
auto-aof-rewrite-percentage 100
#设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写
auto-aof-rewrite-min-size 64mb

#aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。
aof-load-truncated yes

################################ LUA SCRIPTING ###############################
# 如果达到最大时间限制（毫秒），redis会记个log，然后返回error。当一个脚本超过了最大时限。只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。要是已经调用了write，只能用第二个命令杀。
lua-time-limit 5000

################################ REDIS CLUSTER ###############################
#集群开关，默认是不开启集群模式。
# cluster-enabled yes

#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突
# cluster-config-file nodes-6379.conf

#节点互连超时的阀值。集群节点超时毫秒数
# cluster-node-timeout 15000

#在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：
#比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period
#如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移 
# cluster-slave-validity-factor 10

#master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。
# cluster-migration-barrier 1

#默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。
# cluster-require-full-coverage yes

################################## SLOW LOG ###################################
###slog log是用来记录redis运行中执行比较慢的命令耗时。当命令的执行超过了指定时间，就记录在slow log中，slog log保存在内存中，所以没有IO操作。
#执行时间比slowlog-log-slower-than大的请求记录到slowlog里面，单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。
slowlog-log-slower-than 10000

#慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。
slowlog-max-len 128

################################ LATENCY MONITOR ##############################
#延迟监控功能是用来监控redis中执行比较缓慢的一些操作，用LATENCY打印redis实例在跑命令时的耗时图表。只记录大于等于下边设置的值的操作。0的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置。
latency-monitor-threshold 0

############################# EVENT NOTIFICATION ##############################
#键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。
#notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：
##K 键空间通知，所有通知以 __keyspace@__ 为前缀
##E 键事件通知，所有通知以 __keyevent@__ 为前缀
##g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知
##$ 字符串命令的通知
##l 列表命令的通知
##s 集合命令的通知
##h 哈希命令的通知
##z 有序集合命令的通知
##x 过期事件：每当有过期键被删除时发送
##e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送
##A 参数 g$lshzxe 的别名
#输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。详细使用可以参考http://redis.io/topics/notifications

notify-keyspace-events &quot;&quot;

############################### ADVANCED CONFIG ###############################
#数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplist-entries用hash
hash-max-ziplist-entries 512
#value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用hash。
hash-max-ziplist-value 64

#数据量小于等于list-max-ziplist-entries用ziplist，大于list-max-ziplist-entries用list。
list-max-ziplist-entries 512
#value大小小于等于list-max-ziplist-value的用ziplist，大于list-max-ziplist-value用list。
list-max-ziplist-value 64

#数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用set。
set-max-intset-entries 512

#数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset。
zset-max-ziplist-entries 128
#value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset。
zset-max-ziplist-value 64

#value大小小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse），大于hll-sparse-max-bytes使用稠密的数据结构（dense）。一个比16000大的value是几乎没用的，建议的value大概为3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右。
hll-sparse-max-bytes 3000

#Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存。
activerehashing yes

##对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。
#对于normal client，第一个0表示取消hard limit，第二个0和第三个0表示取消soft limit，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的。
client-output-buffer-limit normal 0 0 0
#对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过64mb持续60秒，那么服务器就会立即断开客户端连接。
client-output-buffer-limit slave 256mb 64mb 60
#对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么服务器就会立即断开客户端连接。
client-output-buffer-limit pubsub 32mb 8mb 60

#redis执行任务的频率为1s除以hz。
hz 10

#在aof重写的时候，如果打开了aof-rewrite-incremental-fsync开关，系统会每32MB执行一次fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值。
aof-rewrite-incremental-fsync yes
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;附件2哨兵配置详解&quot;&gt;附件2：哨兵配置详解&lt;/h3&gt;

&lt;p&gt;sentinel.conf配置介绍-&lt;a href=&quot;原文：https://blog.csdn.net/u012441222/article/details/80751390&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;# Example sentinel.conf  
# 哨兵sentinel实例运行的端口 默认26379  
port 26379  

# 哨兵sentinel的工作目录  
dir /tmp  

# 哨兵sentinel监控的redis主节点的 ip port  
# master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。  
# quorum 指定多少个哨兵认为master失联时，确认主节点失联，开始主节点飘移  
# sentinel monitor &amp;lt;master-name&amp;gt; &amp;lt;ip&amp;gt; &amp;lt;redis-port&amp;gt; &amp;lt;quorum&amp;gt;  
  sentinel monitor mymaster 127.0.0.1 6379 2  
  
# 当在Redis实例中开启了授权密码，这样所有连接Redis实例的客户端都要提供密码  
# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码  
# sentinel auth-pass &amp;lt;master-name&amp;gt; &amp;lt;password&amp;gt;  
sentinel auth-pass mymaster MySUPER--secret-0123passw0rd  
  
# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒  
# sentinel down-after-milliseconds &amp;lt;master-name&amp;gt; &amp;lt;milliseconds&amp;gt;  
sentinel down-after-milliseconds mymaster 30000  
  
# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，  
这个数字越小，完成failover所需的时间就越长，  
但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。  
可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。  
# sentinel parallel-syncs &amp;lt;master-name&amp;gt; &amp;lt;numslaves&amp;gt;  
sentinel parallel-syncs mymaster 1  
  
# 故障转移的超时时间 failover-timeout 可以用在以下这些方面：  
#1. 同一个sentinel对同一个master两次failover之间的间隔时间。  
#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。  
#3.当想要取消一个正在进行的failover所需要的时间。  
#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了  
# 默认三分钟  
# sentinel failover-timeout &amp;lt;master-name&amp;gt; &amp;lt;milliseconds&amp;gt;  
sentinel failover-timeout mymaster 180000  
  
# SCRIPTS EXECUTION  
#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。  
#对于脚本的运行结果有以下规则：  
#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10  
#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。  
#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。  
#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。  
  
#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，  
这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，  
一个是事件的类型，  
一个是事件的描述。  
如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。  
#通知脚本  
# sentinel notification-script &amp;lt;master-name&amp;gt; &amp;lt;script-path&amp;gt;  
  sentinel notification-script mymaster /var/redis/notify.sh  
  
# 客户端重新配置主节点参数脚本  
# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。  
# 以下参数将会在调用脚本时传给脚本:  
# &amp;lt;master-name&amp;gt; &amp;lt;role&amp;gt; &amp;lt;state&amp;gt; &amp;lt;from-ip&amp;gt; &amp;lt;from-port&amp;gt; &amp;lt;to-ip&amp;gt; &amp;lt;to-port&amp;gt;  
# 目前&amp;lt;state&amp;gt;总是“failover”,  
# &amp;lt;role&amp;gt;是“leader”或者“observer”中的一个。  
# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的  
# 这个脚本应该是通用的，能被多次调用，不是针对性的。  
# sentinel client-reconfig-script &amp;lt;master-name&amp;gt; &amp;lt;script-path&amp;gt;  
 sentinel client-reconfig-script mymaster /var/redis/reconfig.sh  
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 18 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/redis/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/redis/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Smtp邮件服务原理与拍错</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;背景：最近给一家客户安装服务,发现nodemailer邮件服务怎么发送都失败&lt;br /&gt;
开始的报错是&lt;code class=&quot;highlighter-rouge&quot;&gt;greeting never received&lt;/code&gt;,然后各种尝试添加各种配置项,并未解决问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;终端测试&quot;&gt;终端测试:&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;telnet xxx 25  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;220
HELO xxx  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;250
auth login  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;334&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;等待服务器返回后输入账号密码对应的base64码&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
mail from: xxx &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;250
rcpt to: xxx, xxx
data
Subject: xxx
Hello,
xxx
&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
 发送成功会返回success
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://base64.supfree.net/&quot;&gt;base64加密解密&lt;/a&gt;&lt;br /&gt;
客户加了白名单,跳过auth login这一步,通过终端测试发现可以发送邮件&lt;br /&gt;
通过nodemail发送失败&lt;br /&gt;
在终端测试的过程中发现,telnet 25端口后等待时间很长才会返回20x的响应码&lt;/p&gt;

&lt;h3 id=&quot;抓包分析&quot;&gt;抓包分析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-12-11-smtp/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从抓包文件可以看到:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;123 &lt;/td&gt;
      &lt;td&gt;三次握手后,等待了10s,服务端没有响应&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10s后客户端发起挥手&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;挥手时服务端又返回220&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;789 &lt;/td&gt;
      &lt;td&gt;这时客户端再发起挥手,结束一次请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;smtp包传输正常应该是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-&amp;gt;tcp三次握手  [SYN],[SYN, ACK],[ACK]&lt;/li&gt;
  &lt;li&gt;-&amp;gt;smtp交互完成&lt;/li&gt;
  &lt;li&gt;-&amp;gt;tcp挥手      [FIN, ACK],[ACK]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-12-11-smtp/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;处理&quot;&gt;处理&lt;/h3&gt;

&lt;p&gt;从日志看,服务端10s是有返回的,而客户端10s后则开始挥手,终端测试正常&lt;br /&gt;
所以发现,nodemailer默认的超时时间是10s,于是找到node_modules中smtp-connection/src/smtp-connection.js&lt;br /&gt;
修改320行,将10000超时时间设置为20000,重启邮件服务,解决&lt;br /&gt;
但问题根本在于网络请求服务端等待10s后才响应,排查中..&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/smtp/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/smtp/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Docker最佳实践</title>
        <description>&lt;h1 id=&quot;get-started-with-docker&quot;&gt;Get Started with Docker&lt;/h1&gt;

&lt;p&gt;我都不喜欢照搬官网教程,就从一些示例来说,这样比较快速了解docker&lt;br /&gt;
从nginx的官网docker镜像入门,理解docker&lt;br /&gt;
&lt;a href=&quot;https://hub.docker.com/_/nginx/&quot;&gt;Nginx-Docker镜像地址&lt;/a&gt;&lt;br /&gt;
能看到,有很多tag的镜像版本：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;镜像标注了nginx的版本：mainline和stable,分别表示开发版(主力版)和稳定版(生产环境建议版本)&lt;/li&gt;
  &lt;li&gt;标注了基础镜像版本：stretch(debain)和alpine&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要讲一下基础镜像,所有的dockerfile第一段都是用FROM开头,标明这个dockerfile是在什么镜像的基础上编写的&lt;br /&gt;
作为最底层的基础镜像,就像虚拟机里面的操作系统&lt;br /&gt;
Alpine:优点 小,快,安全&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个alpine的基础镜像只有不到4M,debain差不多120+M&lt;/li&gt;
  &lt;li&gt;alpine的速度快,拉取依赖的速度快&lt;/li&gt;
  &lt;li&gt;因为小,默认不安装bash解释器,漏洞少&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用Alpine作为基础镜像需要注意的点&lt;a href=&quot;http://blog.51cto.com/laodou/2156254&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;库问题&lt;/li&gt;
  &lt;li&gt;DNS问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;alpine仓库中很多&lt;strong&gt;已经编译好的二进制服务的软件包&lt;/strong&gt;是依赖于alpine的musl libc库&lt;br /&gt;
安装这些服务包只需要&lt;code class=&quot;highlighter-rouge&quot;&gt;apk add xxx &lt;/code&gt;直接安装&lt;br /&gt;
仓库中没有的服务包,同时这些服务包依赖于glibc的软件,则需要提前在alpine基础镜像中安装glibc库  gs&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RUN apk &lt;span class=&quot;nt&quot;&gt;--no-cache&lt;/span&gt; add ca-certificates &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    wget &lt;span class=&quot;nt&quot;&gt;-q&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; /etc/apk/keys/sgerrand.rsa.pub https://raw.githubusercontent.com/sgerrand/alpine-pkg-glibc/master/sgerrand.rsa.pub &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    wget https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.27-r0/glibc-2.27-r0.apk &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    apk add glibc-2.27-r0.apk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dns问题官方给出的解释还是和musl libc库有关系&lt;br /&gt;
总结下来就是&lt;strong&gt;musl实现的DNS服务不会使用resolv.conf文件中的search和domain两个配置&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/gliderlabs/docker-alpine/blob/master/docs/caveats.md#dns&quot;&gt;github官方解释&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一是在使用dns作为服务发现时&lt;/li&gt;
  &lt;li&gt;二是在使用并行的dns服务器时,不能确保前一个一直作为默认的dns服务器 &lt;strong&gt;–dns xxx1 –dns xxx2&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;推荐使用dnsmasq,运行时使用&lt;strong&gt;–server /consul/10.0.0.1&lt;/strong&gt;这个参数&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM alpine:edge
RUN apk &lt;span class=&quot;nt&quot;&gt;--no-cache&lt;/span&gt; add dnsmasq
EXPOSE 53 53/udp
ENTRYPOINT &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;dnsmasq&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;-k&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;从nginx的dockerfile来理解docker&quot;&gt;从Nginx的dockerfile来理解docker&lt;/h3&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;FROM alpine:3.8&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;LABEL maintainer=&quot;NGINX Docker Maintainers &amp;lt;docker-maint@nginx.com&amp;gt;&quot;&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;ENV NGINX_VERSION 1.14.2&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;RUN GPG_KEYS=B0F4253373F8F6F510D42178520A9993A1C052F8 \&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;	***&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;	&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ln -sf /dev/stderr /var/log/nginx/error.log&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;COPY nginx.conf /etc/nginx/nginx.conf&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;COPY nginx.vh.default.conf /etc/nginx/conf.d/default.conf&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;EXPOSE &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;STOPSIGNAL SIGTERM&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上文dockerfile，RUN部分的代码省略了,下面做命令的简单解释:&lt;br /&gt;
&lt;strong&gt;RUN命令用&lt;code class=&quot;highlighter-rouge&quot;&gt;\ &amp;amp;&amp;amp;&lt;/code&gt;连接很多命令,因为docker是层的概念,每增加一个指令相当于在镜像上添加一层,所以用连接符将多个命令连接成一个RUN&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FROM: 前面已经说了,声明基础镜像,声明这个dockerfile是基于哪个镜像来生成的&lt;/li&gt;
  &lt;li&gt;LABEL: 没啥作用,标注作者用的&lt;/li&gt;
  &lt;li&gt;ENV: 环境变量声明,类似语言中申明变量一样&lt;/li&gt;
  &lt;li&gt;RUN: 运行命令,一般用户构建过程中的指令,RUN执行的命令是在构建镜像过程中,在基于FROM的基础镜像的系统上执行的命令,所以RUN里面的命令风格要和FROM指定的基础镜像一致,比如上面基于alpine的nginx安装时,RUN时安装包则用&lt;strong&gt;apk add&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;CP: 将宿主机的文件拷贝到镜像内&lt;/li&gt;
  &lt;li&gt;EXPOSE: 指定镜像端口&lt;/li&gt;
  &lt;li&gt;CMD: 最后运行指定,多个时以最后一个为准,CMD只会执行最后一条&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;dockerfile打包的规则是打出尽量小的镜像,&lt;strong&gt;多指令通过连接符、–no-cache,删除过程文件&lt;/strong&gt;均是为了最小化镜像&lt;br /&gt;
在docker17.05之后,docker支持了多阶段构建的-&lt;strong&gt;multi-stage build&lt;/strong&gt;&lt;br /&gt;
通过多阶段构建,解决依赖构建过程,造成镜像包大的问题,因为安装的构建服务只会使用一次&lt;br /&gt;
使用也很简单&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM golang:1.7.3
WORKDIR /go/src/github.com/sparkdevo/href-counter/
RUN go get -d -v golang.org/x/net/html
COPY app.go .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .
 
FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=0 /go/src/github.com/sparkdevo/href-counter/app .
CMD [&quot;./app&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到多阶段构建&lt;br /&gt;
第一阶段即进行依赖构建,将构建好的依赖包拷贝出来&lt;br /&gt;
第二阶段将打好包的依赖CP进去,启动服务&lt;/p&gt;

&lt;p&gt;这样最终生成的镜像仅包含第二阶段的内容,而没有仅仅打包时需要安装的一些库。从而更加精简了docker镜像&lt;br /&gt;
日常使用下来,真正需要手动编写的dockerfile很少,大部分是基于docker官方镜像仓库编好的镜像进行改写&lt;br /&gt;
比如在编写好的nginx增加一个插件,FROM nginx:xxx 然后安装插件,即可&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/docker/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/docker/</guid>
        
        <category>Docker</category>
        
        
      </item>
    
  </channel>
</rss>
