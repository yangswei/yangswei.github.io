<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杨世威</title>
    <description>欢迎来到我的个人站~</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 02 Jan 2019 11:31:32 +0800</pubDate>
    <lastBuildDate>Wed, 02 Jan 2019 11:31:32 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>实用的一些快捷键命令整理</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;一些好用的命令每次要用的时候，不记得怎么用，用起来时区网上查找。死循环，决定整理一份自己常用且好用的一些整理，梳理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;vim快捷键&quot;&gt;Vim快捷键&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Command&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;当前窗口最上方的那行&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;当前末尾，&lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;当前中间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;u&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;撤销&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;重复前一个动作&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;向后删除字符&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;向前删除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:vs xx/xx/file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;垂直分屏打开文件file&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:sp xx/xx/file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;水平分屏打开文件file&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:!command&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;暂时离开vi，到命令行下执行命令&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;linux常用快捷键&quot;&gt;Linux常用快捷键&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Command&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;–命令行快捷键–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+k&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;剪切(删除)光标到行尾的字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+u&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;剪切(删除)光标到行首的字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+w&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;剪切(删除)光标前一个单词&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+y&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;粘贴k,u,w的字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esc+b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动光标到当前单词的开头&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esc+f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动光标到当前单词的结尾&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–ls&amp;amp;ll–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;按时间排序，最新在最前面&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -rt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;按时间倒序排序，最新在最后面&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–去重–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uniq&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;文件去重行或用&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;传替，注意是按行去重&lt;/td&gt;
      &lt;td&gt;eg: &lt;code class=&quot;highlighter-rouge&quot;&gt;cat file|sort|uniq -c&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;linux-一些命令&quot;&gt;Linux 一些命令&lt;/h3&gt;

&lt;p&gt;变量=a,文件=file&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Command&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;–文件处理–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sed -i '/^$/d' file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;清除文件所有空白的行&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sed -i '/#/d'  file&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;清除文件中所有包含某字符的行，以#为例&lt;/td&gt;
      &lt;td&gt;//中间支持正则,比如删除以#开头则^#&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–字符处理–&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if [[ $a =~ ':' ]]&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;判断字符串中是否包含某字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a#*.}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中第一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其左边的字符&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=2.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a##*.}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中最后一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其左边的字符&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a%.*}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中最后一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其右边的字符串&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=1.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a%%.*}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;删掉字符串中第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;及其右边的字符串&lt;/td&gt;
      &lt;td&gt;a=1.2.3 -&amp;gt; a=1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:0:$}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;取字符串第一到最后一个字符&lt;/td&gt;
      &lt;td&gt;eg: ${a:1:2} a=1234 -&amp;gt; a=23&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a/b/c}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将a字符串中的第一个b字符替换成c字符&lt;/td&gt;
      &lt;td&gt;eg: ${a/2/3} a=1232 -&amp;gt; a=1332&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a//b/c}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将a字符串中的所有b字符替换成c字符&lt;/td&gt;
      &lt;td&gt;eg: ${a/2/3} a=1232 -&amp;gt; a=1333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${#a}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;返回一个整数值，数值为字符串长度&lt;/td&gt;
      &lt;td&gt;eg: a=123 echo ${#a} -&amp;gt; 3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a-b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:-b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值或空，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a+b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a空或非空，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:+b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a非空，则使用b为返回值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a=b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值，则使用b为返回值,并赋值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;${a:=b}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;a未赋值或空，则使用b为返回值，并赋值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Thu, 27 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/useful/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/useful/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Redis集群下的那些事</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;背景：近期弄了一套集群环境的服务，其中包含mongo数据库集群，redis集群和其他的服务集群，高可用的架构，为了支持真正意义的高可用，而做了这篇博客&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;集群高可用&quot;&gt;集群高可用&lt;/h3&gt;

&lt;p&gt;以6节点三主三从为例&lt;br /&gt;
cluster-enabled指定启动集群模式&lt;br /&gt;
cluster-config-file指定保存节点配置的文件，redis集群启动后会自动创建修改维护这些nodes.conf文件&lt;/p&gt;

&lt;p&gt;集群模式的最简节点配置文件如下&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;port 7000
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以添加一些配置指定数据文件，日志等&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pidfile /var/run/redis/redis.pid
&lt;span class=&quot;nb&quot;&gt;bind &lt;/span&gt;127.0.0.1 xxx.xxx.xxx.xxx
loglevel notice
logfile /xxx/log/redis/redis.log
dir /xxx/db/redis/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外还有一些配置，例如负载很大的服务修改&lt;strong&gt;tcp-backlog、tcp-keepalive&lt;/strong&gt;参数等&lt;/p&gt;

&lt;p&gt;按上面方法，通过修改监听端口启动的不同节点的redis实例，但还不是集群&lt;br /&gt;
&lt;strong&gt;redis-trib 位于Redis源码的src文件夹中,它是一个Ruby程序&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./redis-trib.rb create --replicas 1  ip1:port1 ip2:port2 ip3:port3 ip4:port4 ip5:port5 ip6:port6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;replicas 1&lt;/code&gt;这个参数指定在6个节点中为每个主节点创建一个从节点，则执行完后会生成对应的三主三从节点配置。&lt;/p&gt;

&lt;h3 id=&quot;哨兵高可用&quot;&gt;哨兵高可用&lt;/h3&gt;

&lt;p&gt;以一主两从三节点介绍&lt;br /&gt;
redis节点的默认配置文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis-default.conf&quot;&gt;daemonize yes
pidfile /var/run/redis/redis.pid
port 6379
tcp-backlog 2048
bind 127.0.0.1 xxx.xxx.xxx.xxx
timeout 0
tcp-keepalive 60
loglevel notice
logfile /xxx/xxx/redis.log
databases 16
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir /xxx/xxx/redis/
slave-serve-stale-data yes
slave-read-only yes
repl-disable-tcp-nodelay no
slave-priority 100
appendonly no
appendfilename &quot;appendonly.aof&quot;
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
lua-time-limit 5000
slowlog-log-slower-than 10000
slowlog-max-len 128
latency-monitor-threshold 0
notify-keyspace-events &quot;&quot;
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-entries 512
list-max-ziplist-value 64
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果加密的话&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis加密&quot;&gt;requirepass  xxxxx  　　#设置redis登录密码
masterauth   xxxxx　　  #主从认证密码，否则主从不能同步
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一主两从，主节点使用上面默认配置启动&lt;br /&gt;
从节点在主节点配置基础上增加一条&lt;code class=&quot;highlighter-rouge&quot;&gt;slaveof 127.0.0.1 6380&lt;/code&gt;  其中ip和端口写主节点的ip和端口&lt;br /&gt;
entinel 哨兵(执行文件和redis-server同目录下)&lt;br /&gt;
每个节点创建一个sentinel.conf文件，在默认的配置上只需修改port,其他的配置三个节点保持一致&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sentinel-default.conf&quot;&gt;port 26379
dir /tmp  
sentinel monitor mymaster 192.168.248.131 6379 2  
sentinel down-after-milliseconds mymaster 30000  
sentinel parallel-syncs mymaster 1  
sentinel failover-timeout mymaster 180000  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果redis需要密码的话加上auth-pass&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis加密&quot;&gt;sentinel auth-pass mymaster xxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动redis主从和哨兵
&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-server redis.conf &amp;amp;&lt;/code&gt;(如果不在一个文件夹下注意路径)&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-sentinel sentinel.conf &amp;amp;&lt;/code&gt;启动sentinel&lt;/p&gt;

&lt;h3 id=&quot;集群高可用和哨兵高可用对比&quot;&gt;集群高可用和哨兵高可用对比&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;单节点&lt;/th&gt;
      &lt;th&gt;集群模式&lt;/th&gt;
      &lt;th&gt;哨兵模式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;运作模式&lt;/td&gt;
      &lt;td&gt;单节点，宕机则停止服务&lt;/td&gt;
      &lt;td&gt;无中心节点，多节点服务&lt;/td&gt;
      &lt;td&gt;由哨兵处理故障转移存在性能瓶颈&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;分片&lt;/td&gt;
      &lt;td&gt;单实例&lt;/td&gt;
      &lt;td&gt;按槽分配，每个节点分配不同的槽，控制每个节点的请求和数据量&lt;/td&gt;
      &lt;td&gt;每个主分担1/N&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可用性&lt;/td&gt;
      &lt;td&gt;无容错性&lt;/td&gt;
      &lt;td&gt;集群节点内置了高可用和复制性能&lt;/td&gt;
      &lt;td&gt;配置sentinel实现复制和高可用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;

&lt;p&gt;还存在一个问题，如果程序中写死了写缓存的地址，但是当masterdown掉之后新的master的地址可能是发生变化的，所以此时我们需要keepalived来实现地址的漂移。&lt;br /&gt;
看到过一遍关于这个方法的解决方案是基于sentinel的keepalived&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/huangyimo/article/details/76618532&quot;&gt;哨兵+keepalived，请参考&lt;/a&gt;&lt;br /&gt;
参考方法中也提到了局限性，包括不受控网络以及云主机环境，无法提供虚拟ip等情况&lt;/p&gt;

&lt;p&gt;这里可通过脚本的方法解决程序缓存地址的问题,能解决没有虚拟ip以及不可控网络的方法&lt;br /&gt;
同样，这个方法无论是集群模式的redis和哨兵模式的redis,都适用&lt;br /&gt;
脚本填入redis节点的ip，并在本地的hosts写入redis解析地址(如果是多master节点，可以改写一下脚本)&lt;br /&gt;
脚本每2秒检测一次当前集群的master，如果master连接不上或者变了，那么脚本会直接替换掉解析中的ip&lt;br /&gt;
程序如果还不能正常，脚本还可以加入重启服务的部分。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#要求1: /etc/hosts里面写入 &quot;1.1.1.1 redis-tb&quot; 的解析规则&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#要求2: 该脚本要有读写/etc/hosts的权限，建议用root&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;hostlist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'1.1.1.1'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2.2.2.2'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'3.3.3.3'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;
checkismaster&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  timeout 3 &lt;span class=&quot;nv&quot;&gt;ismaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;info |timeout 2 redis-cli -h &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;| grep &lt;span class=&quot;s1&quot;&gt;'role'&lt;/span&gt;| awk -F &lt;span class=&quot;s1&quot;&gt;':'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{print $2}'&lt;/span&gt;|grep -w &lt;span class=&quot;s2&quot;&gt;&quot;master&quot;&lt;/span&gt;|wc -l&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt; -eq 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ismaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ismaster&lt;/span&gt; -eq 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;then
     &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;nowhost is master&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else
   &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;nowhost not master&quot;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1
  &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do
  &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;nowhost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;cat /etc/hosts | grep &lt;span class=&quot;s1&quot;&gt;'redis-tb'&lt;/span&gt;| awk &lt;span class=&quot;s1&quot;&gt;'{print $1}'&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
  checkismaster &lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$flag&lt;/span&gt; -eq 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;i &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;hostlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[@]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;do
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;now is finding master in hostlist&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;checking ip --  &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    timeout 3 &lt;span class=&quot;nv&quot;&gt;checkmaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;info |timeout 2 redis-cli -h &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;| grep &lt;span class=&quot;s1&quot;&gt;'role'&lt;/span&gt;| awk -F &lt;span class=&quot;s1&quot;&gt;':'&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{print $2}'&lt;/span&gt;|grep -w &lt;span class=&quot;s2&quot;&gt;&quot;master&quot;&lt;/span&gt;|wc -l&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt; -eq 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;checkmaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;when checkip is master, then checkmaster=1 ---  &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$checkmaster&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$checkmaster&lt;/span&gt; -eq 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;then
     &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;now changeing nowhost to master = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; to &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
     sed -i &lt;span class=&quot;s1&quot;&gt;'s/'&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$nowhost&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/g'&lt;/span&gt; /etc/hosts
    &lt;span class=&quot;k&quot;&gt;fi
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
   &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  sleep 2
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;nohup sh xx.sh &amp;amp;&lt;br /&gt;
将脚本放后台执行，这个脚本会将三个节点的主写到hosts中，并且每两秒检测一次，在应用中写上hosts指定的master地址&lt;/p&gt;

&lt;h3 id=&quot;附件1redis配置详解&quot;&gt;附件1：redis配置详解&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-redis配置详解&quot;&gt;# Redis configuration file example.
# ./redis-server /path/to/redis.conf

################################## INCLUDES ###################################
#这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。
# include /path/to/local.conf
# include /path/to/other.conf

################################ GENERAL #####################################

#是否在后台执行，yes：后台运行；no：不是后台运行（老版本默认）
daemonize yes

  #3.2里的参数，是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码   和bind，可以开启。否   则最好关闭，设置为no。
  protected-mode yes
#redis的进程文件
pidfile /var/run/redis/redis-server.pid

#redis监听的端口号。
port 6379

#此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的/proc/sys/net/core/somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。在/etc/sysctl.conf中添加:net.core.somaxconn = 2048，然后在终端中执行sysctl -p。
tcp-backlog 511

#指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求
bind 127.0.0.1

#配置unix socket来让redis支持监听本地连接。
# unixsocket /var/run/redis/redis.sock
#配置unix socket使用文件的权限
# unixsocketperm 700

# 此参数为设置客户端空闲超过timeout，服务端会断开连接，为0则服务端不会主动断开连接，不能小于0。
timeout 0

#tcp keepalive参数。如果设置不为0，就使用配置tcp的SO_KEEPALIVE值，使用keepalive有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在Linux内核中，设置了keepalive，redis会定时给对端发送ack。检测到对端关闭需要两倍的设置值。
tcp-keepalive 0

#指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的信息，但是没有debug级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息）
loglevel notice

#指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的redis标准输出是/dev/null。
logfile /var/log/redis/redis-server.log

#是否打开记录syslog功能
# syslog-enabled no

#syslog的标识符。
# syslog-ident redis

#日志的来源、设备
# syslog-facility local0

#数据库的数量，默认使用的数据库是DB 0。可以通过”SELECT “命令选择一个db
databases 16

################################ SNAPSHOTTING ################################
# 快照配置
# 注释掉“save”这一行配置项就可以让保存数据库功能失效
# 设置sedis进行数据库镜像的频率。
# 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） 
# 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） 
# 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）
save 900 1
save 300 10
save 60 10000

#当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误
stop-writes-on-bgsave-error yes

#使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间
rdbcompression yes

#是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。
rdbchecksum yes

#rdb文件的名称
dbfilename dump.rdb

#数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录
dir /var/lib/redis

################################# REPLICATION #################################
#复制选项，slave复制对应的master。
# slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;

#如果master设置了requirepass，那么slave要连上master，需要有master的密码才行。masterauth就是用来配置master的密码，这样可以在连上master后进行认证。
# masterauth &amp;lt;master-password&amp;gt;

#当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data设置为no，除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master in progress”。
slave-serve-stale-data yes

#作为从服务器，默认情况下是只读的（yes），可以修改成NO，用于写（不建议）。
slave-read-only yes

#是否使用socket方式复制数据。目前redis复制提供两种方式，disk和socket。如果新的slave连上来或者重连的slave无法部分同步，就会执行全量同步，master会生成rdb文件。有2种方式：disk方式是master创建一个新的进程把rdb文件保存到磁盘，再把磁盘上的rdb文件传递给slave。socket是master创建一个新的进程，直接把rdb文件以socket的方式发给slave。disk方式的时候，当一个rdb保存的过程中，多个slave都能共享这个rdb文件。socket的方式就的一个个slave顺序复制。在磁盘速度缓慢，网速快的情况下推荐用socket方式。
repl-diskless-sync no

#diskless复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。所以最好等待一段时间，等更多的slave连上来。
repl-diskless-sync-delay 5

#slave根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。
# repl-ping-slave-period 10

#复制连接超时时间。master和slave都有超时时间的设置。master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。需要注意的是repl-timeout需要设置一个比repl-ping-slave-period更大的值，不然会经常检测到超时。
# repl-timeout 60

#是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。
repl-disable-tcp-nodelay no

#复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有slave的一段时间，内存会被释放出来，默认1m。
# repl-backlog-size 5mb

#master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。
# repl-backlog-ttl 3600

#当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。而配置成0，永远不会被选举。
slave-priority 100

#redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。
# min-slaves-to-write 3

#延迟小于min-slaves-max-lag秒的slave才认为是健康的slave。
# min-slaves-max-lag 10

# 设置1或另一个设置为0禁用这个特性。
# Setting one or the other to 0 disables the feature.
# By default min-slaves-to-write is set to 0 (feature disabled) and
# min-slaves-max-lag is set to 10.

################################## SECURITY ###################################
#requirepass配置可以让用户使用AUTH命令来认证密码，才能使用其他命令。这让redis可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证。使用requirepass的时候需要注意，因为redis太快了，每秒可以认证15w次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码。
# requirepass foobared

#把危险的命令给修改成其他名称。比如CONFIG命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用。
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52

#设置成一个空的值，可以禁止一个命令
# rename-command CONFIG &quot;&quot;
################################### LIMITS ####################################

# 设置能连上redis的最大客户端连接数量。默认是10000个客户端连接。由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32。如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接。
# maxclients 10000

#redis配置的最大内存容量。当内存满了，需要配合maxmemory-policy策略进行处理。注意slave的输出缓冲区是不计算在maxmemory内的。所以为了防止主机内存使用完，建议设置的maxmemory需要更小一些。
# maxmemory &amp;lt;bytes&amp;gt;

#内存容量超过maxmemory后的处理策略。
#volatile-lru：利用LRU算法移除设置过过期时间的key。
#volatile-random：随机移除设置过过期时间的key。
#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）
#allkeys-lru：利用LRU算法移除任何key。
#allkeys-random：随机移除任何key。
#noeviction：不移除任何key，只是返回一个写错误。
#上面的这些驱逐策略，如果redis没有合适的key驱逐，对于写命令，还是会返回错误。redis将不再接收写请求，只接收get请求。写命令包括：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sort。
# maxmemory-policy noeviction

#lru检测的样本数。使用lru或者ttl淘汰算法，从需要淘汰的列表中随机选择sample个key，选出闲置时间最长的key移除。
# maxmemory-samples 5

############################## APPEND ONLY MODE ###############################
#默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。
appendonly no

#aof文件名
appendfilename &quot;appendonly.aof&quot;

#aof持久化策略的配置
#no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。
#always表示每次写入都执行fsync，以保证数据同步到磁盘。
#everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。
appendfsync everysec

# 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。
no-appendfsync-on-rewrite no

#aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。
auto-aof-rewrite-percentage 100
#设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写
auto-aof-rewrite-min-size 64mb

#aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。
aof-load-truncated yes

################################ LUA SCRIPTING ###############################
# 如果达到最大时间限制（毫秒），redis会记个log，然后返回error。当一个脚本超过了最大时限。只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。要是已经调用了write，只能用第二个命令杀。
lua-time-limit 5000

################################ REDIS CLUSTER ###############################
#集群开关，默认是不开启集群模式。
# cluster-enabled yes

#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突
# cluster-config-file nodes-6379.conf

#节点互连超时的阀值。集群节点超时毫秒数
# cluster-node-timeout 15000

#在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：
#比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period
#如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移 
# cluster-slave-validity-factor 10

#master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。
# cluster-migration-barrier 1

#默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。
# cluster-require-full-coverage yes

################################## SLOW LOG ###################################
###slog log是用来记录redis运行中执行比较慢的命令耗时。当命令的执行超过了指定时间，就记录在slow log中，slog log保存在内存中，所以没有IO操作。
#执行时间比slowlog-log-slower-than大的请求记录到slowlog里面，单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。
slowlog-log-slower-than 10000

#慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。
slowlog-max-len 128

################################ LATENCY MONITOR ##############################
#延迟监控功能是用来监控redis中执行比较缓慢的一些操作，用LATENCY打印redis实例在跑命令时的耗时图表。只记录大于等于下边设置的值的操作。0的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置。
latency-monitor-threshold 0

############################# EVENT NOTIFICATION ##############################
#键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。
#notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：
##K 键空间通知，所有通知以 __keyspace@__ 为前缀
##E 键事件通知，所有通知以 __keyevent@__ 为前缀
##g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知
##$ 字符串命令的通知
##l 列表命令的通知
##s 集合命令的通知
##h 哈希命令的通知
##z 有序集合命令的通知
##x 过期事件：每当有过期键被删除时发送
##e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送
##A 参数 g$lshzxe 的别名
#输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。详细使用可以参考http://redis.io/topics/notifications

notify-keyspace-events &quot;&quot;

############################### ADVANCED CONFIG ###############################
#数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplist-entries用hash
hash-max-ziplist-entries 512
#value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用hash。
hash-max-ziplist-value 64

#数据量小于等于list-max-ziplist-entries用ziplist，大于list-max-ziplist-entries用list。
list-max-ziplist-entries 512
#value大小小于等于list-max-ziplist-value的用ziplist，大于list-max-ziplist-value用list。
list-max-ziplist-value 64

#数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用set。
set-max-intset-entries 512

#数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset。
zset-max-ziplist-entries 128
#value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset。
zset-max-ziplist-value 64

#value大小小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse），大于hll-sparse-max-bytes使用稠密的数据结构（dense）。一个比16000大的value是几乎没用的，建议的value大概为3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右。
hll-sparse-max-bytes 3000

#Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存。
activerehashing yes

##对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。
#对于normal client，第一个0表示取消hard limit，第二个0和第三个0表示取消soft limit，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的。
client-output-buffer-limit normal 0 0 0
#对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过64mb持续60秒，那么服务器就会立即断开客户端连接。
client-output-buffer-limit slave 256mb 64mb 60
#对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么服务器就会立即断开客户端连接。
client-output-buffer-limit pubsub 32mb 8mb 60

#redis执行任务的频率为1s除以hz。
hz 10

#在aof重写的时候，如果打开了aof-rewrite-incremental-fsync开关，系统会每32MB执行一次fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值。
aof-rewrite-incremental-fsync yes
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;附件2哨兵配置详解&quot;&gt;附件2：哨兵配置详解&lt;/h3&gt;

&lt;p&gt;sentinel.conf配置介绍-&lt;a href=&quot;原文：https://blog.csdn.net/u012441222/article/details/80751390&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;# Example sentinel.conf  
# 哨兵sentinel实例运行的端口 默认26379  
port 26379  

# 哨兵sentinel的工作目录  
dir /tmp  

# 哨兵sentinel监控的redis主节点的 ip port  
# master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。  
# quorum 指定多少个哨兵认为master失联时，确认主节点失联，开始主节点飘移  
# sentinel monitor &amp;lt;master-name&amp;gt; &amp;lt;ip&amp;gt; &amp;lt;redis-port&amp;gt; &amp;lt;quorum&amp;gt;  
  sentinel monitor mymaster 127.0.0.1 6379 2  
  
# 当在Redis实例中开启了授权密码，这样所有连接Redis实例的客户端都要提供密码  
# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码  
# sentinel auth-pass &amp;lt;master-name&amp;gt; &amp;lt;password&amp;gt;  
sentinel auth-pass mymaster MySUPER--secret-0123passw0rd  
  
# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒  
# sentinel down-after-milliseconds &amp;lt;master-name&amp;gt; &amp;lt;milliseconds&amp;gt;  
sentinel down-after-milliseconds mymaster 30000  
  
# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，  
这个数字越小，完成failover所需的时间就越长，  
但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。  
可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。  
# sentinel parallel-syncs &amp;lt;master-name&amp;gt; &amp;lt;numslaves&amp;gt;  
sentinel parallel-syncs mymaster 1  
  
# 故障转移的超时时间 failover-timeout 可以用在以下这些方面：  
#1. 同一个sentinel对同一个master两次failover之间的间隔时间。  
#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。  
#3.当想要取消一个正在进行的failover所需要的时间。  
#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了  
# 默认三分钟  
# sentinel failover-timeout &amp;lt;master-name&amp;gt; &amp;lt;milliseconds&amp;gt;  
sentinel failover-timeout mymaster 180000  
  
# SCRIPTS EXECUTION  
#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。  
#对于脚本的运行结果有以下规则：  
#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10  
#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。  
#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。  
#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。  
  
#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，  
这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，  
一个是事件的类型，  
一个是事件的描述。  
如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。  
#通知脚本  
# sentinel notification-script &amp;lt;master-name&amp;gt; &amp;lt;script-path&amp;gt;  
  sentinel notification-script mymaster /var/redis/notify.sh  
  
# 客户端重新配置主节点参数脚本  
# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。  
# 以下参数将会在调用脚本时传给脚本:  
# &amp;lt;master-name&amp;gt; &amp;lt;role&amp;gt; &amp;lt;state&amp;gt; &amp;lt;from-ip&amp;gt; &amp;lt;from-port&amp;gt; &amp;lt;to-ip&amp;gt; &amp;lt;to-port&amp;gt;  
# 目前&amp;lt;state&amp;gt;总是“failover”,  
# &amp;lt;role&amp;gt;是“leader”或者“observer”中的一个。  
# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的  
# 这个脚本应该是通用的，能被多次调用，不是针对性的。  
# sentinel client-reconfig-script &amp;lt;master-name&amp;gt; &amp;lt;script-path&amp;gt;  
 sentinel client-reconfig-script mymaster /var/redis/reconfig.sh  
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 18 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/redis/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/redis/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Smtp邮件服务详解</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;背景：最近给一家客户安装服务,发现nodemailer邮件服务怎么发送都失败&lt;br /&gt;
开始的报错是&lt;code class=&quot;highlighter-rouge&quot;&gt;greeting never received&lt;/code&gt;,然后各种尝试添加各种配置项,并未解决问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;终端测试&quot;&gt;终端测试:&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;telnet xxx 25  --&amp;gt;220
HELO xxx  --&amp;gt;250
auth login  --&amp;gt;334&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;等待服务器返回后输入账号密码对应的base64码&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
mail from: xxx --&amp;gt;250
rcpt to: xxx, xxx
data
Subject: xxx
Hello,
xxx
.
 发送成功会返回success
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://base64.supfree.net/&quot;&gt;base64加密解密&lt;/a&gt;&lt;br /&gt;
客户加了白名单,跳过auth login这一步,通过终端测试发现可以发送邮件&lt;br /&gt;
通过nodemail发送失败&lt;br /&gt;
在终端测试的过程中发现,telnet 25端口后等待时间很长才会返回20x的响应码&lt;/p&gt;

&lt;h3 id=&quot;抓包分析&quot;&gt;抓包分析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-12-11-smtp/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从抓包文件可以看到:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;123 &lt;/td&gt;
      &lt;td&gt;三次握手后,等待了10s,服务端没有响应&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10s后客户端发起挥手&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;挥手时服务端又返回220&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;789 &lt;/td&gt;
      &lt;td&gt;这时客户端再发起挥手,结束一次请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;smtp包传输正常应该是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-&amp;gt;tcp三次握手  [SYN],[SYN, ACK],[ACK]&lt;/li&gt;
  &lt;li&gt;-&amp;gt;smtp交互完成&lt;/li&gt;
  &lt;li&gt;-&amp;gt;tcp挥手      [FIN, ACK],[ACK]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018-12-11-smtp/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;处理&quot;&gt;处理&lt;/h3&gt;

&lt;p&gt;从日志看,服务端10s是有返回的,而客户端10s后则开始挥手,终端测试正常&lt;br /&gt;
所以发现,nodemailer默认的超时时间是10s,于是找到node_modules中smtp-connection/src/smtp-connection.js&lt;br /&gt;
修改320行,将10000超时时间设置为20000,重启邮件服务,解决&lt;br /&gt;
但问题根本在于网络请求服务端等待10s后才响应,排查中..&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/smtp/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/smtp/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Docker从入门到使用系列</title>
        <description>&lt;h1 id=&quot;get-started-with-docker&quot;&gt;Get Started with Docker&lt;/h1&gt;

&lt;p&gt;我都不喜欢照搬官网教程,就从一些示例来说,这样比较快速了解docker&lt;br /&gt;
从nginx的官网docker镜像入门,理解docker&lt;br /&gt;
&lt;a href=&quot;https://hub.docker.com/_/nginx/&quot;&gt;Nginx-Docker镜像地址&lt;/a&gt;&lt;br /&gt;
能看到,有很多tag的镜像版本：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;镜像标注了nginx的版本：mainline和stable,分别表示开发版(主力版)和稳定版(生产环境建议版本)&lt;/li&gt;
  &lt;li&gt;标注了基础镜像版本：stretch(debain)和alpine&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要讲一下基础镜像,所有的dockerfile第一段都是用FROM开头,标明这个dockerfile是在什么镜像的基础上编写的&lt;br /&gt;
作为最底层的基础镜像,就像虚拟机里面的操作系统&lt;br /&gt;
Alpine:优点 小,快,安全&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个alpine的基础镜像只有不到4M,debain差不多120+M&lt;/li&gt;
  &lt;li&gt;alpine的速度快,拉取依赖的速度快&lt;/li&gt;
  &lt;li&gt;因为小,默认不安装bash解释器,漏洞少&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用Alpine作为基础镜像需要注意的点&lt;a href=&quot;http://blog.51cto.com/laodou/2156254&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;库问题&lt;/li&gt;
  &lt;li&gt;DNS问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;alpine仓库中很多&lt;strong&gt;已经编译好的二进制服务的软件包&lt;/strong&gt;是依赖于alpine的musl libc库&lt;br /&gt;
安装这些服务包只需要&lt;code class=&quot;highlighter-rouge&quot;&gt;apk add xxx &lt;/code&gt;直接安装&lt;br /&gt;
仓库中没有的服务包,同时这些服务包依赖于glibc的软件,则需要提前在alpine基础镜像中安装glibc库  gs&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RUN apk --no-cache add ca-certificates &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    wget -q -O /etc/apk/keys/sgerrand.rsa.pub https://raw.githubusercontent.com/sgerrand/alpine-pkg-glibc/master/sgerrand.rsa.pub &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    wget https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.27-r0/glibc-2.27-r0.apk &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    apk add glibc-2.27-r0.apk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Dns问题官方给出的解释还是和musl libc库有关系&lt;br /&gt;
总结下来就是&lt;strong&gt;musl实现的DNS服务不会使用resolv.conf文件中的search和domain两个配置&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/gliderlabs/docker-alpine/blob/master/docs/caveats.md#dns&quot;&gt;github官方解释&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一是在使用dns作为服务发现时&lt;/li&gt;
  &lt;li&gt;二是在使用并行的dns服务器时,不能确保前一个一直作为默认的dns服务器 &lt;strong&gt;–dns xxx1 –dns xxx2&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;推荐使用dnsmasq,运行时使用&lt;strong&gt;–server /consul/10.0.0.1&lt;/strong&gt;这个参数&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM alpine:edge
RUN apk --no-cache add dnsmasq
EXPOSE 53 53/udp
ENTRYPOINT &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;dnsmasq&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;-k&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;从nginx的dockerfile来理解docker&quot;&gt;从Nginx的dockerfile来理解docker&lt;/h3&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;FROM alpine:3.8&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;LABEL maintainer=&quot;NGINX Docker Maintainers &amp;lt;docker-maint@nginx.com&amp;gt;&quot;&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;ENV NGINX_VERSION 1.14.2&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;RUN GPG_KEYS=B0F4253373F8F6F510D42178520A9993A1C052F8 \&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;	***&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;	&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ln -sf /dev/stderr /var/log/nginx/error.log&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;COPY nginx.conf /etc/nginx/nginx.conf&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;COPY nginx.vh.default.conf /etc/nginx/conf.d/default.conf&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;EXPOSE 80&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;STOPSIGNAL SIGTERM&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上文dockerfile，RUN部分的代码省略了,下面做命令的简单解释:&lt;br /&gt;
&lt;strong&gt;RUN命令用&lt;code class=&quot;highlighter-rouge&quot;&gt;\ &amp;amp;&amp;amp;&lt;/code&gt;连接很多命令,因为docker是层的概念,每增加一个指令相当于在镜像上添加一层,所以用连接符将多个命令连接成一个RUN&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FROM: 前面已经说了,声明基础镜像,声明这个dockerfile是基于哪个镜像来生成的&lt;/li&gt;
  &lt;li&gt;LABEL: 没啥作用,标注作者用的&lt;/li&gt;
  &lt;li&gt;ENV: 环境变量声明,类似语言中申明变量一样&lt;/li&gt;
  &lt;li&gt;RUN: 运行命令,一般用户构建过程中的指令,RUN执行的命令是在构建镜像过程中,在基于FROM的基础镜像的系统上执行的命令,所以RUN里面的命令风格要和FROM指定的基础镜像一致,比如上面基于alpine的nginx安装时,RUN时安装包则用&lt;strong&gt;apk add&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;CP: 将宿主机的文件拷贝到镜像内&lt;/li&gt;
  &lt;li&gt;EXPOSE: 指定镜像端口&lt;/li&gt;
  &lt;li&gt;CMD: 最后运行指定,多个时以最后一个为准,CMD只会执行最后一条&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;dockerfile打包的规则是打出尽量小的镜像,&lt;strong&gt;多指令通过连接符、–no-cache,删除过程文件&lt;/strong&gt;均是为了最小化镜像&lt;br /&gt;
在docker17.05之后,docker支持了多阶段构建的-&lt;strong&gt;multi-stage build&lt;/strong&gt;&lt;br /&gt;
通过多阶段构建,解决依赖构建过程,造成镜像包大的问题,因为安装的构建服务只会使用一次&lt;br /&gt;
使用也很简单&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM golang:1.7.3
WORKDIR /go/src/github.com/sparkdevo/href-counter/
RUN go get -d -v golang.org/x/net/html
COPY app.go .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .
 
FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=0 /go/src/github.com/sparkdevo/href-counter/app .
CMD [&quot;./app&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到多阶段构建&lt;br /&gt;
第一阶段即进行依赖构建,将构建好的依赖包拷贝出来&lt;br /&gt;
第二阶段将打好包的依赖CP进去,启动服务&lt;/p&gt;

&lt;p&gt;这样最终生成的镜像仅包含第二阶段的内容,而没有仅仅打包时需要安装的一些库。从而更加精简了docker镜像&lt;br /&gt;
日常使用下来,真正需要手动编写的dockerfile很少,大部分是基于docker官方镜像仓库编好的镜像进行改写&lt;br /&gt;
比如在编写好的nginx增加一个插件,FROM nginx:xxx 然后安装插件,即可&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/docker/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/docker/</guid>
        
        <category>Docker</category>
        
        
      </item>
    
      <item>
        <title>2018年的第一场雪</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;2018年的第一场大雪,比以往更晚一些&lt;br /&gt;
闲来无事,回忆往年。&lt;br /&gt;
越来越不喜欢发朋友圈了,大概是没了激情或者是不需要用朋友圈来抒发自己的感情,可是若干年后对自己的过往便无迹可寻了。
以后还是将朋友圈利用起来,权当做对自己的轨迹记录&lt;br /&gt;
从朋友圈09年至今来回忆过往的人和事儿&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;仙鹤&quot;&gt;仙鹤&lt;/h3&gt;

&lt;p&gt;  高中同学,当时的女友,如今的老婆~&lt;br /&gt;
  恋爱11年,如今已经开启两人世界,就不细谈了,后续专门写一篇记事来回忆&lt;/p&gt;

&lt;h3 id=&quot;小的哥&quot;&gt;小的哥&lt;/h3&gt;

&lt;p&gt;  大表哥,当然会一直联系啦,表哥高中成绩就很好,在太中(当时县城里最好的高中),后面表哥考到了安徽财经大学,从小就经常一起玩,特别聪明,下棋特厉害(我好像很少赢他),还记得以前在外婆家,一起田间足球赛,一起去游泳,现在也还是会经常联系,小的哥谈了一个女朋友特神秘,目前还没正式的介绍过女朋友,表哥也到了要结婚的年龄了,哈哈,早点结婚,嘿嘿&lt;/p&gt;

&lt;h3 id=&quot;汪科&quot;&gt;汪科&lt;/h3&gt;

&lt;p&gt;  高中以来的同学,一直以来关系很好的兄弟,一直联系。这个说来就话长了,一直以来最好的兄弟,高中一起早上4点起来打篮球,高二时虽然一个分到1班一个4班,还是会经常在一起玩,还记得高一时,怂恿他和许文静传纸条。哈哈,不过后来好像他和许文静也比较少联系了,大学时和汪科其吖聚会了一次,那是第一次仙鹤到合肥见我,那时他两还是单身,有一次打电话,我：兄弟恋爱了吗？ 科：谈了啊  我：哈哈,开玩笑的吧 然后确定大学汪科谈恋爱了,女朋友是附近学校的.
  最近的一次聚会就要追溯到去年了,也是在合肥,汪科做3d打印,那时我工作还很迷,不知道在干啥,其吖也不知道在干嘛,好像是在送外卖,养了一条金毛,特别粘人的金毛,后面听说还咬了汪科一口,哈哈,后面听说金毛丢了&lt;br /&gt;
  如今已经是十多年的兄弟了,回忆着有点想他们了,最近找个时间去和他们聚一聚,聊聊最近的大家吧~&lt;/p&gt;

&lt;h3 id=&quot;李汪&quot;&gt;李汪&lt;/h3&gt;

&lt;p&gt;  小学,初中,高中同学,其实没想到能寻迹的朋友圈,第一个评论会是他,如今已经很久没联系了.李汪一直是很厉害的,成绩好,而且足球踢的很厉害,后面读初中,高中就没见他踢过了,想必是全心投入学习了吧。如今很少联系了,虽然听说大家都在上海,不过已经很久没联系了,不知道再见面,会是怎么样。&lt;/p&gt;

&lt;h3 id=&quot;许文静&quot;&gt;许文静&lt;/h3&gt;

&lt;p&gt;  初中同学,高中同学,当年属于比较漂亮然后如今偶尔也会朋友圈交流,映象里一直是很漂亮,而且比较前卫,哈哈,初中听说和男生恋爱过,不知道是不是真的,虽然是很久的同学,不过一直没联络的很多,当初其实觉得是女神级别的,不敢靠近,虽然是初高中同学,但是没有很多交流,有一次大学时在李汪家聚会见过一次,然后再太湖街头碰过一次面,然后再也没见过,去年玩游戏时联系过一阵子,如今也结婚了,当然这都是后面才知道的,因为游戏联系过几次,如今也是朋友圈联系了&lt;/p&gt;

&lt;h3 id=&quot;杨勇&quot;&gt;杨勇&lt;/h3&gt;

&lt;p&gt;  高中同学,目前还在联系目前大家都在上海&lt;br /&gt;
  认识很久了,到大学后也很少联系的朋友,如今大家在上海了见过几次面,如今已经是孩子爸了。哈哈&lt;/p&gt;

&lt;h3 id=&quot;李倩倩&quot;&gt;李倩倩&lt;/h3&gt;

&lt;p&gt;  初中同学,高中校友,原来比较好的朋友,如今已经很久没有联络了。&lt;br /&gt;
  其实还算是蛮多感触的,高中时算是很好的朋友了吧,一直以来当做是很好的朋友,成绩蛮好的记得当初是英语课代表,复习班时,我给她写过一封信,如今忘记内容了。倩倩应该算是很我很欣赏的那种女孩类型的,记忆里是温柔的然后属于比较内向的,笑起来很甜的那种,记忆里,在某天复习班下晚自习后,一起在操场长聊了一次,也忘记聊了什么&lt;br /&gt;
  已经很久没有联络过了,望安好吧&lt;/p&gt;

&lt;h3 id=&quot;老甲&quot;&gt;老甲&lt;/h3&gt;

&lt;p&gt;  高中同学,复习同学。关系很好的兄弟,一直在联系&lt;br /&gt;
  这个,哈哈哈,很好的兄弟,高中班长,一直算是很有领导力的感觉的,复习班时一个班,算是战友了,记忆比较丰满了,高中时,身为班长,组织脱大家裤子的。emm,我也被凌辱过,当时脱裤事件很严重,后面班主任还专门开过一个班会,(所有男生留下)大发雷霆。哈哈,复习班大家都很努力,一起奋斗过,也相互鼓励,一个复习班宿舍,em,还一起脱过毕原的裤子,恶行啊,不知道小毕还有没有阴影,哈哈
  现在也经常联系,结婚时可是我的伴郎哦~&lt;br /&gt;
  不过和嫂子妹的爱情长跑还在继续,希望他们能幸福,如果最后老甲和嫂子妹终成眷属了,那应该是比我和仙鹤更久的爱情长跑了~
  一定要幸福,加油！&lt;/p&gt;

&lt;h3 id=&quot;许好好&quot;&gt;许好好&lt;/h3&gt;

&lt;p&gt;  高中同学,em,怎么说呢,高中时联络的很多,后续慢慢联络就少了。好好记忆里人缘很好,高二时,聊过很多,记得还一起过元旦,一起看烟花,宛然是一对cp,高三我很无源头的没有理她,我自己也不知道原因,然后我背上了花心的名头,后来很多人说我花心,emm.不过这段记忆很久没说了,还是记录下来以免忘记了吧&lt;br /&gt;
  如今大家很多年没有联系,还算是朋友吧&lt;/p&gt;

&lt;h3 id=&quot;汪鹏雨&quot;&gt;汪鹏雨&lt;/h3&gt;

&lt;p&gt;  复习班班长,em,一直喊我老小,可能是比我大两岁吧,哈哈哈,复习班的班长,成绩貌似很好,复习班全身心在学习上,几乎花一年学三年,所以记忆里交集只是学习,后来联系过,在考研,读研,然后进了一家企业当管理~&lt;br /&gt;
  认我做小弟的大哥,哈哈,虽然联系很少~&lt;/p&gt;

&lt;h3 id=&quot;张曦&quot;&gt;张曦&lt;/h3&gt;

&lt;p&gt;  大学同学,很热情的一个朋友,如今少有联系了,大学的大姐大,团支书,一起进过停尸房的扛把子,映象里很热情,大大咧咧的一个人,很热心,然后很好相处,性格超好,不过结婚后应该是个操心命,hahaha&lt;br /&gt;
  是一个很好很热心肠的朋友,不过却没有经常里联系&lt;br /&gt;
  后来曦姐读研了,如今在合肥工作,还未婚,去年聊过一次,好像也比较着急找男朋友了哈哈&lt;br /&gt;
  点点是曦姐家的狗狗,大学时一直嚷嚷要吃掉它,想来那已经是9年前了,话说狗狗寿命还蛮长的&lt;/p&gt;

&lt;h3 id=&quot;汉利贺超&quot;&gt;汉利&amp;amp;贺超&lt;/h3&gt;

&lt;p&gt;  大学室友,如今也少有联系了,汉利一直比较自律,比较腼腆内向&lt;br /&gt;
  贺超我比较喜欢欺负他,哈哈,肉肉的,虽然后来大二没在一个宿舍每次路过还会去袭胸&lt;br /&gt;
  后来他们都考研了,如今都在合肥,贺超谈了女朋友,如今快结婚了,汉利也好久没联系了&lt;/p&gt;

&lt;h3 id=&quot;王婷&quot;&gt;王婷&lt;/h3&gt;

&lt;p&gt;  王婷应该算是典型的温柔型女生了吧,大学时一起玩过,当时和江幼学恋爱了,记得是大三还是大二的时候开始的&lt;br /&gt;
  如今在本地的县城上班,结婚了&lt;/p&gt;

&lt;h3 id=&quot;小胡方进涛子&quot;&gt;小胡&amp;amp;方进&amp;amp;涛子&lt;/h3&gt;

&lt;p&gt;  朋友圈还没看到小胡和方进,后来大二的室友一起说吧,大学关系最铁的,因为大二是自由组合一个宿舍,就关系好的组合到一个宿舍,所以大二一分到一个宿舍就玩到一起了,基本大学后面四个人一起吃饭,一起打球,一起游戏,几乎几个人一直到要毕业了都大多时候在一起&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;和小胡一起打篮球,天黑,小胡请吃西瓜两人两瓜&lt;/li&gt;
  &lt;li&gt;和涛一起走错教室,一起打小抄,一起二级计算机被抓,哈哈&lt;/li&gt;
  &lt;li&gt;和小进子一起去图书馆看书,划水&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  一起游戏,我和涛冲锋,小胡打狙。一起去网吧包夜,一起翘课,一起喝酒&lt;br /&gt;
  还有王文宇,一个宿舍的大神,大学比较少和我们几个一起,基本都在把妹或者把妹的路上,抽屉都是情趣内衣,算是高人了&lt;br /&gt;
  如今涛在做少儿教育这块,已经结婚了,对象是圆圆,一直被我们调侃成球球&lt;br /&gt;
  小进子在做php开发,结婚了,对象是大学快毕业谈的&lt;br /&gt;
  小胡在做通信相关的,结婚了,对象是张璐,是有个假期回来突然就恋爱了,当时整个宿舍都很诧异,然后小胡从逗比转换成温柔大叔,每天电话粥,晚上小胡拜拜能拜拜半个多小时,emm&lt;br /&gt;
  虽然如今哥几个很久没聚了,回忆起来,还是很暖心,很怀念那段时光,过阵子也找个时间大家聚一聚吧&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/diary01/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/diary01/</guid>
        
        <category>diary</category>
        
        
      </item>
    
      <item>
        <title>科学上网</title>
        <description>&lt;h2 id=&quot;安装&quot;&gt;安装：&lt;/h2&gt;

&lt;h3 id=&quot;服务端安装&quot;&gt;服务端安装&lt;/h3&gt;

&lt;p&gt;linux服务器服务端(在国外服务器上执行)&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;wget --no-check-certificate https://freed.ga/github/shadowsocksR.sh; bash shadowsocksR.sh&lt;/code&gt;&lt;br /&gt;
执行完成后监听端口为执行过程中的默认端口&lt;br /&gt;
在客户端按脚本输出信息配置连接信息&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;客户端安装&quot;&gt;客户端安装&lt;/h3&gt;

&lt;p&gt;客户端下载地址:&lt;br /&gt;
&lt;a href=&quot;href=&amp;quot;https://freed.ga/ShadowSocksR/ShadowsocksR-4.7.0.zip&amp;quot;&quot;&gt;windows&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://freed.ga/ShadowSocksR/shadowsocksr-release.apk&quot;&gt;android&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://freed.ga/ShadowSocksR/macOS%20Sierra%2010.10.x.zip&quot;&gt;mac&lt;/a&gt;&lt;br /&gt;
ios的到appstore找一个,目前貌似大部分要收费了~&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理：&lt;/h2&gt;

&lt;p&gt;转自: &lt;a href=&quot;https://vc2tea.com/whats-shadowsocks/&quot;&gt;https://vc2tea.com/whats-shadowsocks/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;很久前，访问google的方式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/netcont/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;被墙&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/netcont/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初代解决方法,利用海外服务器直接代理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/netcont/3.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
1 首先用户和境外服务器基于ssh建立起一条加密的通道&lt;br /&gt;
2-3 用户通过建立起的隧道进行代理,通过ssh server向真实的服务发起请求&lt;br /&gt;
4-5 服务通过ssh server,再通过创建好的隧道返回给用户&lt;br /&gt;
由于ssh本身就是基于RSA加密技术,所以GFW无法从数据传输的过程中的加密数据内容进行关键词分析,避免了被重置链接的问题,但由于创建隧道和数据传输的过程中,ssh本身的特征是明显的,所以GFW一度通过分析连接的特征进行干扰,导致ssh存在被定向进行干扰的问题&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Shadowsocks原理:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/netcont/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;简单理解的话,shadowsocks是将原来ssh创建的Socks5协议拆开成server端和client端，所以下面这个原理图基本上和利用ssh tunnel大致类似&lt;br /&gt;
1&amp;amp;6 客户端发出的请求基于Socks5协议跟ss-local端进行通讯,由于这个ss-local一般是本机或路由器或局域网的其他机器,不经过GFW,所以解决了上面被GFW通过特征分析进行干扰的问题&lt;br /&gt;
2&amp;amp;5 ss-local和ss-server两端通过多种可选的加密方法进行通讯,经过GFW的时候是常规的TCP包,没有明显的特征码而且GFW也无法对通讯数据进行解密&lt;br /&gt;
3&amp;amp;4 ss-server将收到的加密数据进行解密,还原原来的请求,再发送到用户需要访问的服务,获取响应原路返回&lt;/p&gt;
</description>
        <pubDate>Fri, 09 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/netcon/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/netcon/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>基础企业级Linux优化整理</title>
        <description>&lt;h1 id=&quot;生产环境优化&quot;&gt;生产环境优化&lt;/h1&gt;

&lt;h3 id=&quot;开机启动&quot;&gt;开机启动&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chkconfig --list|grep 3:on&lt;/code&gt;查看当前开机开启服务
&lt;br /&gt;
关闭其他开机启动的服务&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;i &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;chkconfig --list|grep &lt;span class=&quot;s1&quot;&gt;'3:on'&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;'{print $1}'&lt;/span&gt;|grep -vE &lt;span class=&quot;s2&quot;&gt;&quot;crond|network|sshd|rsyslog|sysstat&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;;&lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;chkconfig &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; off;done
&lt;span class=&quot;c&quot;&gt;#执行完以后再查看一下开机启动的服务&lt;/span&gt;
chkconfig --list|grep 3:on

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
其他开机启动服务原则是：只保留使用的服务，清楚系统上每个服务的角色，最小化系统服务。&lt;/p&gt;

&lt;h3 id=&quot;防火墙&quot;&gt;防火墙&lt;/h3&gt;
&lt;p&gt;防火墙个人学习或者企业级高并发高流量服务器一般都不开启，因为开启防火墙会有较大的性能损耗，解决此类问题及在更前端用硬件防火墙进行安全防护
&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/init.d/iptables stop&lt;/code&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;远程连接&quot;&gt;远程连接&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;linux系统配置修改后恢复比较麻烦，建议修改配置前备份一份，如果容易忘记，则设置一下命令别名
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim /etc/profile
&lt;span class=&quot;c&quot;&gt;#在末尾添加一行alias，这样每次vim会自动在vim的目录创建一个备份&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'func() { cp -f  $1 $1-bk; vim $1;}; func'&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;修改配置&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;vim /etc/ssh/sshd_config&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Port&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;设置远程连接端口,默认22&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PermitEmptyPasswords&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;远程用户空密码登录，设置为no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PermitRootLogin&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;是否允许root用户直接登录,设置为no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UseDNS no&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;是否反向解析ip,设置为no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GSSAPIAuthentication no&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;解决慢连接&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/init.d/sshd reload&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;权限管理&quot;&gt;权限管理&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;visudo
在文件的98行给对应普通用户加权限
用户名|机器&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;授权角色&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;|可执行命令
xxx &lt;span class=&quot;nv&quot;&gt;ALL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;ALL&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; NOPASSWD: ALL 
表示xxx 可通过sudo 执行所以系统命令，并不需要密码提示
最后的ALL表示所有命令，可指定某些命令，用逗号隔开
xxx &lt;span class=&quot;nv&quot;&gt;ALL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;ALL&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; NOPASSWD: vim,cp,find
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;关键系统文件上锁&quot;&gt;关键系统文件上锁&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#上锁&lt;/span&gt;
chattr +i /etc/passwd /etc/shadow /etc/group /etc/gshadow /etc/inittab
&lt;span class=&quot;c&quot;&gt;#解锁&lt;/span&gt;
chattr -i /etc/passwd /etc/shadow /etc/group /etc/gshadow /etc/inittab
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;升级已知漏洞软件版本&quot;&gt;升级已知漏洞软件版本&lt;/h3&gt;

&lt;p&gt;升级到最新&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;openssl&lt;/li&gt;
  &lt;li&gt;openssh&lt;/li&gt;
  &lt;li&gt;bash&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;内核优化&quot;&gt;内核优化&lt;/h3&gt;

&lt;p&gt;内核部分根据实际需要优化&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数名&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;默认值&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;建议值&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_syn_retries&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对外TCP连接请求时,内核尝试发送syn请求的次数,默认5次大概180秒，对内请求是由参数tcp_retries1控制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_synack_retries&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对外TCP的第二步，尝试发送SYN +ACK次数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_keepalive_time&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7200&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1800&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;当网络两端建立了TCP连接之后，闲置tcp_keepalive_time时间后，内核会向客户端发送侦测包判断tcp连接情况&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_keepalive_probes&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;内核会向客户端发送tcp_keepalive_probes次侦测包判断tcp连接情况&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_keepalive_intvl&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;75&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;内核向客户端发送侦测包未获得响应时,隔tcp_keepalive_intvl时间,再发一次侦测&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_retries1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;放弃回应一个TCP连接请求前,进行tcp_retries1次重试,最低为3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_retries2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;丢弃已建立的tcp前,进行多少次重试&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_orphan_retries&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在近端丢弃TCP前，重试多少次&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_fin_timeout&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;60&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对于本端断开的socket连接，TCP保持的时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_max_tw_buckets&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;180000&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;36000&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;系统在同时所处理的最大timewait sockets数目&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_tw_recycle&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;快速TIME-WAIT sockets回收&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_tw_reuse&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_max_orphans&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8192&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;32768&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;系统所能处理不属于任何进程的TCP sockets最大数量,超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_syncookies&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_max_syn_backlog&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1024&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16384&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_reordering&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TCP流中重排序的数据报最大数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_retrans_collapse&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对于某些有bug的打印机提供针对其bug的兼容性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_wmem：mindefaultmax&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4096/16384/131072&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8192/131072/16777216&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;发送缓存设置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_rmem：mindefaultmax&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4096/16384/131072&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8192/131072/16777216&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;接收缓存设置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp_mem：mindefaultmax&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;内存计算&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;786432/1048576/1572864&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ip_local_port_range:minmax&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;32768/61000&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1024/65000&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;表示用于向外连接的端口范围&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;netdev_max_backlog&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1024&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16384&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目，对重负载服务器而言，该值需要调高一点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;somaxconn&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;128&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16384&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用来限制监听(LISTEN)队列最大数据包的数量，超过这个数量就会导致链接超时或者触发重传机制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rmem_max&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;129024&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;873200&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;最大的TCP数据接收缓冲&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wmem_max&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;129024&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;873200&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;最大的TCP数据发送缓冲&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat /etc/sysctl.conf 

net.ipv4.tcp_syn_retries &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1
net.ipv4.tcp_synack_retries &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1
net.ipv4.tcp_keepalive_time &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 600
net.ipv4.tcp_keepalive_probes &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 3
net.ipv4.tcp_keepalive_intvl &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15
net.ipv4.tcp_retries2 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 5
net.ipv4.tcp_fin_timeout &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 2
net.ipv4.tcp_max_tw_buckets &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 36000
net.ipv4.tcp_tw_recycle &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1
net.ipv4.tcp_tw_reuse &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1
net.ipv4.tcp_max_orphans &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 32768
net.ipv4.tcp_syncookies &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1
net.ipv4.tcp_max_syn_backlog &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 16384
net.ipv4.tcp_wmem &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 8192 131072 16777216
net.ipv4.tcp_rmem &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 32768 131072 16777216
net.ipv4.tcp_mem &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 786432 1048576 1572864
net.ipv4.ip_local_port_range &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1024 65000
net.ipv4.ip_conntrack_max &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 65536
net.ipv4.netfilter.ip_conntrack_max&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;65536
net.ipv4.netfilter.ip_conntrack_tcp_timeout_established&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;180
net.core.somaxconn &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 16384
net.core.netdev_max_backlog &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 16384
vm.swappiness&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 06 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/linux/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/linux/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>博客添加live2d</title>
        <description>&lt;h1 id=&quot;为博客添加女朋友&quot;&gt;为博客添加女朋友&lt;/h1&gt;

&lt;h2 id=&quot;下载live2d-models-库&quot;&gt;下载live2d models 库&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/xiazeyu/live2d-widget-models&quot;&gt;github地址&lt;/a&gt;&lt;br /&gt;
下载live2d库，&lt;a href=&quot;https://huaji8.top/post/live2d-plugin-2.0/&quot;&gt;查看预览图&lt;/a&gt;&lt;br /&gt;
选择一个models,记住名字，下面的models名字均以z16为例，选择其他名字替换z16即可 
在live2d-widget-models目录下，npm install live2d-widget-model-z16&lt;/p&gt;

&lt;h2 id=&quot;生成静态的文件&quot;&gt;生成静态的文件&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install hexo-cli -g
hexo init blog
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;blog
npm install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;进入blog目录，安装hexo-helper-live2d，&lt;a href=&quot;https://github.com/EYHN/hexo-helper-live2d&quot;&gt;链接&lt;/a&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install --save hexo-helper-live2d&lt;/code&gt;&lt;br /&gt;
如果不成功：&lt;code class=&quot;highlighter-rouge&quot;&gt;yarn add hexo-helper-live2d&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;修改_config.xml&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;live2d&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;scriptFrom&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;local&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;pluginRootPath&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;live2dw/&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;pluginJsPath&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;lib/&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;pluginModelPath&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;assets/&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;tagMode&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;z16&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;right&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;150&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;300&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;mobile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了model.use的名字，根据选择的model名外，其他的配置保持不变&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拷贝文件到hexo中&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;blog
mkdir live2d_models &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;live2d_models &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mkdir z16 
&lt;span class=&quot;c&quot;&gt;#将live2d-widget-models目录下live2d-widget-model-z16/assets/下的文件拷贝到 blog/live2d_models/z16下&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将目录拷贝到blog的live2d_models下后执行&lt;strong&gt;hexo serve&lt;/strong&gt;查看是否已经有了z16&lt;br /&gt;
在blog目录，执行&lt;strong&gt;hexo deploy&lt;/strong&gt;&lt;br /&gt;
生成的静态文件在blog/public/live2d下&lt;br /&gt;
引用文件在index.html中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态文件导入jeklly&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cp blog/public/live2d    jeklly-blog的根目录&lt;/code&gt;
将hexo的index.html的引用文件添加到jeklly的footer.html中&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;L2Dwidget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pluginRootPath&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;live2dw/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pluginJsPath&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;lib/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pluginModelPath&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;assets/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tagMode&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;model&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jsonPath&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/live2dw/assets/z16.model.json&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;display&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;position&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;right&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;width&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;height&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mobile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;show&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;log&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完成。&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/live2d/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/live2d/</guid>
        
        <category>博客</category>
        
        
      </item>
    
      <item>
        <title>K8s集群-fek插件</title>
        <description>&lt;h2 id=&quot;安装插件前准备工作&quot;&gt;安装插件前准备工作&lt;/h2&gt;

&lt;p&gt;github地址: &lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot;&gt;https://github.com/kubernetes/kubernetes&lt;/a&gt;&lt;br /&gt;
路径为kubenetes/cluster/addons/fluentd-elasticsearch&lt;/p&gt;

&lt;p&gt;选择对应版本的k8s分支,然后下载对应的es,fluentd,kibana的yaml文件，一共6个文件。&lt;br /&gt;
在github上提供了官方的image地址:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;k8s.gcr.io/elasticsearch:v5.6.4
k8s.gcr.io/fluentd-elasticsearch:v2.0.4
docker.elastic.co/kibana/kibana:5.6.4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这些镜像貌似都被墙了，可以翻墙将镜像下载到本地，然后调整yaml的iamge地址，或者找找一些大牛将这些镜像放到国内cdn提供下载的地址。&lt;br /&gt;
另外在gihub里面提供了完整的dockerfile，可以自定义编辑镜像,如果要使用额外的plugin插件，则在fluentd的Gemfile中将要额外增加的插件添加进去，然后本地build镜像。&lt;/p&gt;

&lt;h3 id=&quot;调整文件&quot;&gt;调整文件&lt;/h3&gt;

&lt;p&gt;fluentd会根据配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;fluentd-es-configmap.yaml&lt;/code&gt;指定的规则收集系统日志，然后按规定格式打到els中，kibana读取els日志前端展示 &lt;br /&gt;
Fluentd+elasticsearch+kibana中配置相对复杂一些的就是fluentd。
设置node节点的标签,只在标记了标签的节点上运行fluentd&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl get nodes&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl label nodes nodenamexxx beta.kubernetes.io/fluentd-ds-ready=true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;调整默认kibana的yaml文件,设置type为NodePort然后指定nodeport&lt;br /&gt;
调整elasticsearch的statefulset文件，调整limits&amp;amp;requests的cpu，按实际的需要来进行调整大小（至少2G+）&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;curl ip:9200/_cat/indices?v&lt;/code&gt;&lt;br /&gt;
内存不够时，索引的状态会&lt;strong&gt;red&lt;/strong&gt;,单节点的els索引状态为&lt;strong&gt;yellow&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;按实际需要调整fluentd的configmap&quot;&gt;按实际需要调整fluentd的configmap&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;k8s组件&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日志内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;kube-controller-manager&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;pod扩容或rc&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kube-scheduler&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;pod扩容或rc&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kubelet&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;pod周期相关：创建、停止&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;k8s组件收集的日志是k8s集群的日志，实际的应用场景中，需要查看的是k8s集群中对应的服务打印出来的日志，在Linux系统上systemd系统来管理kubernetes服务，并且journal系统会接管服务程序的输出日志，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl -u docker -o json-pretty -f&lt;/code&gt;来查看服务的日志.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;__CURSOR&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;__REALTIME_TIMESTAMP&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;__MONOTONIC_TIMESTAMP&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_BOOT_ID&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;PRIORITY&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_UID&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_GID&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_CAP_EFFECTIVE&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_SYSTEMD_CGROUP&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_MACHINE_ID&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_HOSTNAME&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_TRANSPORT&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;SYSLOG_FACILITY&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_STREAM_ID&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;SYSLOG_IDENTIFIER&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_PID&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_COMM&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;dockerd-current&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_EXE&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_CMDLINE&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_SYSTEMD_UNIT&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;MESSAGE&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;fluentd-configmap指定源数据，匹配所有系统日志中_COMM值为&lt;code class=&quot;highlighter-rouge&quot;&gt;dockerd-current&lt;/code&gt;的日志记录为源日志数据
输出部分说明，我所使用的环境中用到的插件有：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;rewrite_tag_filter&lt;/li&gt;
  &lt;li&gt;kubernetes_metadata&lt;/li&gt;
  &lt;li&gt;record_transformer&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;source&amp;gt;
@type systemd
path /var/log/journal
filters [{ &quot;_COMM&quot;: &quot;dockerd-current&quot; }]
#pos_file /tmp/fluentd/journal.pos
tag journal
strip_underscores true
read_from_head true
&amp;lt;/source&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;匹配journal的日志数据，将container_name以k8s_开头的日志打上tag标签
注意：官方的image中没有安装rewrite_tag_filter插件，在dockerfile指定的Gemfile添加
&lt;code class=&quot;highlighter-rouge&quot;&gt;gem 'fluent-plugin-rewrite-tag-filter','~&amp;gt;2.1.0'&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;&amp;lt;match journal&amp;gt;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;type rewrite_tag_filter&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;rule&amp;gt;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;key CONTAINER_NAME&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;pattern ^k8s_&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;tag kubernetes.journal.container&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;/rule&amp;gt;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;log_level trace&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;/match&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据上文打好的标签，过滤标签，将kubernetes.xx的标签匹配后，
通过kubernetes_metadata将日志数据格式化&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;&amp;lt;filter kubernetes.**&amp;gt;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;type kubernetes_metadata&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;use_journal true&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;同上，匹配标签，使用record_transformer插件，添加topic&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;filter kubernetes.**&amp;gt;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;type record_transformer&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;enable_ruby&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;record&amp;gt;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;topic k8s-${record[&quot;kubernetes&quot;][&quot;container_name&quot;]}&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;/record&amp;gt;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;最后匹配所有，将日志按index_name保存到els中&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;match **&amp;gt;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;id elasticsearch&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;type elasticsearch&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;log_level info&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#只有tag_key是topic的日志才会输入到els中&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;include_tag_key true&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;tag_key topic&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;host elasticsearch-logging&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;port 9200&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#logstash_format true&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#将日志的topic匹配索引的key[这里key的值定义为topic]，&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#如果日志的topic=索引的key,则将对应的日志打入对应的索引中&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;target_index_key topic&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;index_name logstash-${topic}&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;buffer&amp;gt;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;type file&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;path /var/log/fluentd-buffers/kubernetes.system.buffer&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;flush_mode interval&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;retry_type exponential_backoff&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;flush_thread_count 2&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;flush_interval 5s&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;retry_forever&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;retry_max_interval 30&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;chunk_limit_size 2M&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;queue_limit_length 8&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;overflow_action block&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;/buffer&amp;gt;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;lt;/match&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;插件作用：
&lt;code class=&quot;highlighter-rouge&quot;&gt;rewrite_tag_filter&lt;/code&gt;插件是从source源匹配的日志中，过滤找到&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTAINER_NAME&lt;/code&gt;以k8s开头的日志，将过滤出来的日志打上tag
另外两个插件分别是将源文件进行格式处理
metadata将日志中添加对应kubenetes的信息，类似容器名，namespace名等，record则是添加一个topic字段，topic名为k8s-容器的pod名&lt;/p&gt;

&lt;p&gt;最后在match中将日志按index=topic的规则写到对应的index中（index的值即为容器名:k8s-appname-xxx)
在kibana中即能够定义&lt;code class=&quot;highlighter-rouge&quot;&gt;Index Patterns&lt;/code&gt;的值为k8s-appname*&lt;/p&gt;

&lt;h3 id=&quot;检验&quot;&gt;检验&lt;/h3&gt;

&lt;p&gt;查看所有pod启动情况：
&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl get pods -n kube-system -o wide|grep -E 'elasticsearch|fluentd|kibana'&lt;/code&gt;     &lt;br /&gt;
查看service情况：   &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl get service  -n kube-system|grep -E 'elasticsearch|kibana'&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;注意&quot;&gt;注意&lt;/h3&gt;

&lt;p&gt;如果els经常报错，可以将els相关的组件从k8s中移除，单独运行elasticsearch。
然后在修改kibana和fluentd中指定的elasticsearch地址，指定elasticsearch的位置。&lt;/p&gt;

&lt;p&gt;kibana中加上：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- name: XPACK_SECURITY_ENABLED       
    value: &quot;false&quot;       
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;elasticsearch的docker-compose文件&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: '2'      
services:      
  elasticsearch:      
    image: docker.elastic.co/elasticsearch/elasticsearch:5.6.2      
    expose:      
      - 9200      
    ports:     
      - &quot;9200:9200&quot;      
    environment:      
      - bootstrap.memory_lock=true      
      - xpack.security.enabled=false      
      - &quot;ES_JAVA_OPTS=-Xms8G -Xmx8G&quot;      
    ulimits:      
      memlock:      
        soft: -1      
        hard: -1      
    volumes:      
      - /Elasticsearch/data:/usr/share/elasticsearch/data      
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 24 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/fek/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/fek/</guid>
        
        <category>Docker</category>
        
        
      </item>
    
      <item>
        <title>百度网盘Svip破解</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;github开源破解百度限速工具[mac版]
[github地址] (https://github.com/CodeTips/BaiduNetdiskPlugin-macOS)&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;需要本地安装git&lt;/li&gt;
    &lt;li&gt;mac上安装百度网盘&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~/Downloads &amp;amp;&amp;amp; git clone https://github.com/CodeTips/BaiduNetdiskPlugin-macOS.git &amp;amp;&amp;amp; ./BaiduNetdiskPlugin-macOS/Other/Install.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一键安装即可完成
测试了一下，没有提速，但是解除了限速~&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/baidudisk/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/baidudisk/</guid>
        
        <category>工具</category>
        
        
      </item>
    
  </channel>
</rss>
